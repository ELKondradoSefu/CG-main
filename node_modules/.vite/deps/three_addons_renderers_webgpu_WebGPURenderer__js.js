import {
  CodeNode_default,
  MeshBasicNodeMaterial_default,
  NodeBuilder_default,
  NodeFrame_default,
  NodeMaterial_default,
  WGSLNodeParser_default,
  context,
  cubeTexture,
  densityFog,
  equirectUV,
  lights,
  modelWorldMatrix,
  positionWorld,
  positionWorldDirection,
  rangeFog,
  reference,
  texture,
  toneMapping,
  transformDirection,
  viewportBottomLeft
} from "./chunk-M3FWZGAL.js";
import {
  AddEquation,
  AdditiveBlending,
  AlwaysDepth,
  AlwaysStencilFunc,
  BackSide,
  BoxGeometry,
  Color,
  CubeTexture,
  CustomBlending,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Float16BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  HalfFloatType,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InvertStencilOp,
  KeepStencilOp,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  LinearFilter,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MinEquation,
  MirroredRepeatWrapping,
  MultiplyBlending,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoToneMapping,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  RGBAFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC2_Format,
  RGFormat,
  RedFormat,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  SRGBColorSpace,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  SubtractEquation,
  SubtractiveBlending,
  Texture,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VideoTexture,
  WebGLRenderTarget,
  ZeroFactor,
  ZeroStencilOp
} from "./chunk-BP3ERIIO.js";
import "./chunk-JC4IRQUL.js";

// node_modules/three/examples/jsm/renderers/webgpu/constants.js
var GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
};
var GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
};
var GPUStoreOp = {
  Store: "store",
  Discard: "discard"
};
var GPULoadOp = {
  Load: "load",
  Clear: "clear"
};
var GPUFrontFace = {
  CCW: "ccw",
  CW: "cw"
};
var GPUCullMode = {
  None: "none",
  Front: "front",
  Back: "back"
};
var GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32"
};
var GPUTextureFormat = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10uFloat: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  // Depth and stencil formats
  Stencil8: "stencil8",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
};
var GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest"
};
var GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  SrcColor: "src-color",
  OneMinusSrcColor: "one-minus-src-color",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  DstColor: "dst-color",
  OneMinusDstColor: "one-minus-dst-color",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  BlendColor: "blend-color",
  OneMinusBlendColor: "one-minus-blend-color"
};
var GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
};
var GPUColorWriteFlags = {
  None: 0,
  Red: 1,
  Green: 2,
  Blue: 4,
  Alpha: 8,
  All: 15
};
var GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
};
var GPUBindingType = {
  UniformBuffer: "uniform-buffer",
  StorageBuffer: "storage-buffer",
  ReadonlyStorageBuffer: "readonly-storage-buffer",
  Sampler: "sampler",
  ComparisonSampler: "comparison-sampler",
  SampledTexture: "sampled-texture",
  MultisampledTexture: "multisampled-texture",
  ReadonlyStorageTexture: "readonly-storage-texture",
  WriteonlyStorageTexture: "writeonly-storage-texture"
};
var GPUTextureDimension = {
  OneD: "1d",
  TwoD: "2d",
  ThreeD: "3d"
};
var GPUTextureViewDimension = {
  OneD: "1d",
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  CubeArray: "cube-array",
  ThreeD: "3d"
};
var GPUTextureAspect = {
  All: "all",
  StencilOnly: "stencil-only",
  DepthOnly: "depth-only"
};
var GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance"
};
var GPUFeatureName = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable"
};
var GPUChunkSize = 16;
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUAnimation.js
var WebGPUAnimation = class {
  constructor() {
    this.nodes = null;
    this.animationLoop = null;
    this.requestId = null;
    this.isAnimating = false;
    this.context = self;
  }
  start() {
    if (this.isAnimating === true || this.animationLoop === null || this.nodes === null)
      return;
    this.isAnimating = true;
    const update = (time, frame) => {
      this.requestId = self.requestAnimationFrame(update);
      this.nodes.nodeFrame.update();
      this.animationLoop(time, frame);
    };
    this.requestId = self.requestAnimationFrame(update);
  }
  stop() {
    self.cancelAnimationFrame(this.requestId);
    this.isAnimating = false;
  }
  setAnimationLoop(callback) {
    this.animationLoop = callback;
  }
  setNodes(nodes) {
    this.nodes = nodes;
  }
};
var WebGPUAnimation_default = WebGPUAnimation;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUWeakMap.js
var WebGPUWeakMap = class extends WeakMap {
  constructor() {
    super();
  }
  get(keys) {
    if (Array.isArray(keys)) {
      let map = this;
      for (let i = 0; i < keys.length - 1; i++) {
        map = map.get(keys[i]);
        if (map === void 0)
          return void 0;
      }
      return map.get(keys[keys.length - 1]);
    } else {
      return super.get(keys);
    }
  }
  set(keys, value) {
    if (Array.isArray(keys)) {
      let map = this;
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (map.has(key) === false)
          map.set(key, /* @__PURE__ */ new WeakMap());
        map = map.get(key);
      }
      return map.set(keys[keys.length - 1], value);
    } else {
      return super.set(keys, value);
    }
  }
  delete(keys) {
    if (Array.isArray(keys)) {
      let map = this;
      for (let i = 0; i < keys.length - 1; i++) {
        map = map.get(keys[i]);
        if (map === void 0)
          return false;
      }
      return map.delete(keys[keys.length - 1]);
    } else {
      return super.delete(keys);
    }
  }
};

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderObject.js
var WebGPURenderObject = class {
  constructor(renderer, nodes, object, material, scene, camera, lightsNode) {
    this.renderer = renderer;
    this.nodes = nodes;
    this.object = object;
    this.material = material;
    this.scene = scene;
    this.camera = camera;
    this.lightsNode = lightsNode;
    this.geometry = object.geometry;
    this._materialVersion = -1;
    this._materialCacheKey = "";
  }
  getCacheKey() {
    const { material, scene, lightsNode } = this;
    if (material.version !== this._materialVersion) {
      this._materialVersion = material.version;
      this._materialCacheKey = material.customProgramCacheKey();
    }
    const cacheKey = [];
    cacheKey.push("material:" + this._materialCacheKey);
    cacheKey.push("nodes:" + this.nodes.getCacheKey(scene, lightsNode));
    return "{" + cacheKey.join(",") + "}";
  }
};

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderObjects.js
var WebGPURenderObjects = class {
  constructor(renderer, nodes, geometries, info) {
    this.renderer = renderer;
    this.nodes = nodes;
    this.geometries = geometries;
    this.info = info;
    this.cache = new WebGPUWeakMap();
  }
  get(object, material, scene, camera, lightsNode) {
    const chainKey = [object, material, scene, camera, lightsNode];
    let renderObject = this.cache.get(chainKey);
    if (renderObject === void 0) {
      renderObject = new WebGPURenderObject(this.renderer, this.nodes, object, material, scene, camera, lightsNode);
      this.cache.set(chainKey, renderObject);
    }
    return renderObject;
  }
  remove(object, material, scene, camera, lightsNode) {
    this.cache.delete([object, material, scene, camera, lightsNode]);
  }
  dispose() {
    this.cache = new WebGPUWeakMap();
    this.updateMap = /* @__PURE__ */ new WeakMap();
  }
};
var WebGPURenderObjects_default = WebGPURenderObjects;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUAttributes.js
var WebGPUAttributes = class {
  constructor(device) {
    this.buffers = /* @__PURE__ */ new WeakMap();
    this.device = device;
  }
  get(attribute) {
    attribute = this._getAttribute(attribute);
    return this.buffers.get(attribute);
  }
  remove(attribute) {
    attribute = this._getAttribute(attribute);
    const data = this.buffers.get(attribute);
    if (data) {
      this._destroyBuffers(data);
      this.buffers.delete(attribute);
    }
  }
  update(attribute, isIndex = false, usage = null) {
    attribute = this._getAttribute(attribute);
    let data = this.buffers.get(attribute);
    if (data === void 0) {
      if (usage === null) {
        usage = isIndex === true ? GPUBufferUsage.INDEX : GPUBufferUsage.VERTEX;
      }
      data = this._createBuffer(attribute, usage);
      this.buffers.set(attribute, data);
    } else if (usage && usage !== data.usage) {
      this._destroyBuffers(data);
      data = this._createBuffer(attribute, usage);
      this.buffers.set(attribute, data);
    } else if (data.version < attribute.version) {
      this._writeBuffer(data.buffer, attribute);
      data.version = attribute.version;
    }
  }
  async getArrayBuffer(attribute) {
    const data = this.get(attribute);
    const device = this.device;
    const gpuBuffer = data.buffer;
    const size = gpuBuffer.size;
    let gpuReadBuffer = data.readBuffer;
    let needsUnmap = true;
    if (gpuReadBuffer === null) {
      gpuReadBuffer = device.createBuffer({
        label: attribute.name,
        size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      needsUnmap = false;
      data.readBuffer = gpuReadBuffer;
    }
    const cmdEncoder = device.createCommandEncoder({});
    cmdEncoder.copyBufferToBuffer(
      gpuBuffer,
      0,
      gpuReadBuffer,
      0,
      size
    );
    if (needsUnmap)
      gpuReadBuffer.unmap();
    const gpuCommands = cmdEncoder.finish();
    device.queue.submit([gpuCommands]);
    await gpuReadBuffer.mapAsync(GPUMapMode.READ);
    const arrayBuffer = gpuReadBuffer.getMappedRange();
    return arrayBuffer;
  }
  _getAttribute(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return attribute;
  }
  _createBuffer(attribute, usage) {
    const array = attribute.array;
    const size = array.byteLength + (4 - array.byteLength % 4) % 4;
    const buffer = this.device.createBuffer({
      label: attribute.name,
      size,
      usage: usage | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new array.constructor(buffer.getMappedRange()).set(array);
    buffer.unmap();
    attribute.onUploadCallback();
    return {
      version: attribute.version,
      buffer,
      readBuffer: null,
      usage
    };
  }
  _writeBuffer(buffer, attribute) {
    const device = this.device;
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    if (updateRange.count === -1) {
      device.queue.writeBuffer(
        buffer,
        0,
        array,
        0
      );
    } else {
      device.queue.writeBuffer(
        buffer,
        0,
        array,
        updateRange.offset * array.BYTES_PER_ELEMENT,
        updateRange.count * array.BYTES_PER_ELEMENT
      );
      updateRange.count = -1;
    }
  }
  _destroyBuffers({ buffer, readBuffer }) {
    buffer.destroy();
    if (readBuffer !== null)
      readBuffer.destroy();
  }
};
var WebGPUAttributes_default = WebGPUAttributes;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUGeometries.js
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535)
      return true;
  }
  return false;
}
function getWireframeVersion(geometry) {
  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
}
function getWireframeIndex(geometry) {
  const indices = [];
  const geometryIndex = geometry.index;
  const geometryPosition = geometry.attributes.position;
  if (geometryIndex !== null) {
    const array = geometryIndex.array;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const a = array[i + 0];
      const b = array[i + 1];
      const c = array[i + 2];
      indices.push(a, b, b, c, c, a);
    }
  } else {
    const array = geometryPosition.array;
    for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
      const a = i + 0;
      const b = i + 1;
      const c = i + 2;
      indices.push(a, b, b, c, c, a);
    }
  }
  const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
  attribute.version = getWireframeVersion(geometry);
  return attribute;
}
var WebGPUGeometries = class {
  constructor(attributes, properties, info) {
    this.attributes = attributes;
    this.properties = properties;
    this.info = info;
    this.wireframes = /* @__PURE__ */ new WeakMap();
    this.geometryFrame = /* @__PURE__ */ new WeakMap();
  }
  has(renderObject) {
    const geometry = renderObject.geometry;
    return this.properties.has(geometry) && this.properties.get(geometry).initialized === true;
  }
  update(renderObject) {
    if (this.has(renderObject) === false)
      this.initGeometry(renderObject);
    this.updateFrameAttributes(renderObject);
  }
  initGeometry(renderObject) {
    const geometry = renderObject.geometry;
    const geometryProperties = this.properties.get(geometry);
    geometryProperties.initialized = true;
    const dispose = () => {
      this.info.memory.geometries--;
      const index = geometry.index;
      const geometryAttributes = geometry.attributes;
      if (index !== null) {
        this.attributes.remove(index);
      }
      for (const name in geometryAttributes) {
        this.attributes.remove(geometryAttributes[name]);
      }
      const wireframeAttribute = this.wireframes.get(geometry);
      if (wireframeAttribute !== void 0) {
        this.attributes.remove(wireframeAttribute);
      }
      geometry.removeEventListener("dispose", dispose);
    };
    this.info.memory.geometries++;
    geometry.addEventListener("dispose", dispose);
  }
  updateFrameAttributes(renderObject) {
    const frame = this.info.render.frame;
    const geometry = renderObject.geometry;
    if (this.geometryFrame.get(geometry) !== frame) {
      this.updateAttributes(renderObject);
      this.geometryFrame.set(geometry, frame);
    }
  }
  updateAttributes(renderObject) {
    const geometry = renderObject.geometry;
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      this.attributes.update(geometryAttributes[name]);
    }
    const index = this.getIndex(renderObject);
    if (index !== null) {
      this.attributes.update(index, true);
    }
  }
  getIndex(renderObject) {
    const { geometry, material } = renderObject;
    let index = geometry.index;
    if (material.wireframe === true) {
      const wireframes = this.wireframes;
      let wireframeAttribute = wireframes.get(geometry);
      if (wireframeAttribute === void 0) {
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
        this.attributes.remove(wireframeAttribute);
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      }
      index = wireframeAttribute;
    }
    return index;
  }
};
var WebGPUGeometries_default = WebGPUGeometries;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUInfo.js
var WebGPUInfo = class {
  constructor() {
    this.autoReset = true;
    this.render = {
      frame: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(object, count, instanceCount) {
    this.render.drawCalls++;
    if (object.isMesh || object.isSprite) {
      this.render.triangles += instanceCount * (count / 3);
    } else if (object.isPoints) {
      this.render.points += instanceCount * count;
    } else if (object.isLineSegments) {
      this.render.lines += instanceCount * (count / 2);
    } else if (object.isLine) {
      this.render.lines += instanceCount * (count - 1);
    } else {
      console.error("THREE.WebGPUInfo: Unknown object type.");
    }
  }
  reset() {
    this.render.frame++;
    this.render.drawCalls = 0;
    this.render.triangles = 0;
    this.render.points = 0;
    this.render.lines = 0;
  }
  dispose() {
    this.reset();
    this.render.frame = 0;
    this.memory.geometries = 0;
    this.memory.textures = 0;
  }
};
var WebGPUInfo_default = WebGPUInfo;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUProperties.js
var WebGPUProperties = class {
  constructor() {
    this.properties = /* @__PURE__ */ new WeakMap();
  }
  get(object) {
    let map = this.properties.get(object);
    if (map === void 0) {
      map = {};
      this.properties.set(object, map);
    }
    return map;
  }
  remove(object) {
    this.properties.delete(object);
  }
  has(object) {
    return this.properties.has(object);
  }
  dispose() {
    this.properties = /* @__PURE__ */ new WeakMap();
  }
};
var WebGPUProperties_default = WebGPUProperties;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderPipeline.js
var typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
var typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Float16BufferAttribute, ["float16"]]
]);
var typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Uint32Array, "uint32"],
  [Float32Array, "float32"]
]);
var WebGPURenderPipeline = class {
  constructor(device, utils) {
    this.cacheKey = null;
    this.shaderAttributes = null;
    this.stageVertex = null;
    this.stageFragment = null;
    this.usedTimes = 0;
    this._device = device;
    this._utils = utils;
  }
  init(cacheKey, stageVertex, stageFragment, renderObject, nodeBuilder) {
    const { object, material, geometry } = renderObject;
    const shaderAttributes = this._getShaderAttributes(nodeBuilder, geometry);
    const vertexBuffers = [];
    for (const attribute of shaderAttributes) {
      const name = attribute.name;
      const geometryAttribute = geometry.getAttribute(name);
      const stepMode = geometryAttribute !== void 0 && geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
      vertexBuffers.push({
        arrayStride: attribute.arrayStride,
        attributes: [{ shaderLocation: attribute.slot, offset: attribute.offset, format: attribute.format }],
        stepMode
      });
    }
    this.cacheKey = cacheKey;
    this.shaderAttributes = shaderAttributes;
    this.stageVertex = stageVertex;
    this.stageFragment = stageFragment;
    let alphaBlend = {};
    let colorBlend = {};
    if (material.transparent === true && material.blending !== NoBlending) {
      alphaBlend = this._getAlphaBlend(material);
      colorBlend = this._getColorBlend(material);
    }
    let stencilFront = {};
    if (material.stencilWrite === true) {
      stencilFront = {
        compare: this._getStencilCompare(material),
        failOp: this._getStencilOperation(material.stencilFail),
        depthFailOp: this._getStencilOperation(material.stencilZFail),
        passOp: this._getStencilOperation(material.stencilZPass)
      };
    }
    const primitiveState = this._getPrimitiveState(object, geometry, material);
    const colorWriteMask = this._getColorWriteMask(material);
    const depthCompare = this._getDepthCompare(material);
    const colorFormat = this._utils.getCurrentColorFormat();
    const depthStencilFormat = this._utils.getCurrentDepthStencilFormat();
    const sampleCount = this._utils.getSampleCount();
    this.pipeline = this._device.createRenderPipeline({
      vertex: Object.assign({}, stageVertex.stage, { buffers: vertexBuffers }),
      fragment: Object.assign({}, stageFragment.stage, { targets: [{
        format: colorFormat,
        blend: {
          alpha: alphaBlend,
          color: colorBlend
        },
        writeMask: colorWriteMask
      }] }),
      primitive: primitiveState,
      depthStencil: {
        format: depthStencilFormat,
        depthWriteEnabled: material.depthWrite,
        depthCompare,
        stencilFront,
        stencilBack: {},
        // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
        stencilReadMask: material.stencilFuncMask,
        stencilWriteMask: material.stencilWriteMask
      },
      multisample: {
        count: sampleCount
      },
      layout: "auto"
    });
  }
  _getAlphaBlend(material) {
    const blending = material.blending;
    const premultipliedAlpha = material.premultipliedAlpha;
    let alphaBlend = void 0;
    switch (blending) {
      case NormalBlending:
        if (premultipliedAlpha === false) {
          alphaBlend = {
            srcFactor: GPUBlendFactor.One,
            dstFactor: GPUBlendFactor.OneMinusSrcAlpha,
            operation: GPUBlendOperation.Add
          };
        }
        break;
      case AdditiveBlending:
        alphaBlend = {
          srcFactor: GPUBlendFactor.Zero,
          dstFactor: GPUBlendFactor.One,
          operation: GPUBlendOperation.Add
        };
        break;
      case SubtractiveBlending:
        if (premultipliedAlpha === true) {
          alphaBlend = {
            srcFactor: GPUBlendFactor.OneMinusSrcColor,
            dstFactor: GPUBlendFactor.OneMinusSrcAlpha,
            operation: GPUBlendOperation.Add
          };
        }
        break;
      case MultiplyBlending:
        if (premultipliedAlpha === true) {
          alphaBlend = {
            srcFactor: GPUBlendFactor.Zero,
            dstFactor: GPUBlendFactor.SrcAlpha,
            operation: GPUBlendOperation.Add
          };
        }
        break;
      case CustomBlending:
        const blendSrcAlpha = material.blendSrcAlpha;
        const blendDstAlpha = material.blendDstAlpha;
        const blendEquationAlpha = material.blendEquationAlpha;
        if (blendSrcAlpha !== null && blendDstAlpha !== null && blendEquationAlpha !== null) {
          alphaBlend = {
            srcFactor: this._getBlendFactor(blendSrcAlpha),
            dstFactor: this._getBlendFactor(blendDstAlpha),
            operation: this._getBlendOperation(blendEquationAlpha)
          };
        }
        break;
      default:
        console.error("THREE.WebGPURenderer: Blending not supported.", blending);
    }
    return alphaBlend;
  }
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case ZeroFactor:
        blendFactor = GPUBlendFactor.Zero;
        break;
      case OneFactor:
        blendFactor = GPUBlendFactor.One;
        break;
      case SrcColorFactor:
        blendFactor = GPUBlendFactor.SrcColor;
        break;
      case OneMinusSrcColorFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcColor;
        break;
      case SrcAlphaFactor:
        blendFactor = GPUBlendFactor.SrcAlpha;
        break;
      case OneMinusSrcAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case DstColorFactor:
        blendFactor = GPUBlendFactor.DstColor;
        break;
      case OneMinusDstColorFactor:
        blendFactor = GPUBlendFactor.OneMinusDstColor;
        break;
      case DstAlphaFactor:
        blendFactor = GPUBlendFactor.DstAlpha;
        break;
      case OneMinusDstAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusDstAlpha;
        break;
      case SrcAlphaSaturateFactor:
        blendFactor = GPUBlendFactor.SrcAlphaSaturated;
        break;
      case BlendColorFactor:
        blendFactor = GPUBlendFactor.BlendColor;
        break;
      case OneMinusBlendColorFactor:
        blendFactor = GPUBlendFactor.OneMinusBlendColor;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", blend);
    }
    return blendFactor;
  }
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case AddEquation:
        blendOperation = GPUBlendOperation.Add;
        break;
      case SubtractEquation:
        blendOperation = GPUBlendOperation.Subtract;
        break;
      case ReverseSubtractEquation:
        blendOperation = GPUBlendOperation.ReverseSubtract;
        break;
      case MinEquation:
        blendOperation = GPUBlendOperation.Min;
        break;
      case MaxEquation:
        blendOperation = GPUBlendOperation.Max;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend equation not supported.", blendEquation);
    }
    return blendOperation;
  }
  _getColorBlend(material) {
    const blending = material.blending;
    const premultipliedAlpha = material.premultipliedAlpha;
    const colorBlend = {
      srcFactor: null,
      dstFactor: null,
      operation: null
    };
    switch (blending) {
      case NormalBlending:
        colorBlend.srcFactor = premultipliedAlpha === true ? GPUBlendFactor.One : GPUBlendFactor.SrcAlpha;
        colorBlend.dstFactor = GPUBlendFactor.OneMinusSrcAlpha;
        colorBlend.operation = GPUBlendOperation.Add;
        break;
      case AdditiveBlending:
        colorBlend.srcFactor = premultipliedAlpha === true ? GPUBlendFactor.One : GPUBlendFactor.SrcAlpha;
        colorBlend.dstFactor = GPUBlendFactor.One;
        colorBlend.operation = GPUBlendOperation.Add;
        break;
      case SubtractiveBlending:
        colorBlend.srcFactor = GPUBlendFactor.Zero;
        colorBlend.dstFactor = premultipliedAlpha === true ? GPUBlendFactor.Zero : GPUBlendFactor.OneMinusSrcColor;
        colorBlend.operation = GPUBlendOperation.Add;
        break;
      case MultiplyBlending:
        colorBlend.srcFactor = GPUBlendFactor.Zero;
        colorBlend.dstFactor = GPUBlendFactor.SrcColor;
        colorBlend.operation = GPUBlendOperation.Add;
        break;
      case CustomBlending:
        colorBlend.srcFactor = this._getBlendFactor(material.blendSrc);
        colorBlend.dstFactor = this._getBlendFactor(material.blendDst);
        colorBlend.operation = this._getBlendOperation(material.blendEquation);
        break;
      default:
        console.error("THREE.WebGPURenderer: Blending not supported.", blending);
    }
    return colorBlend;
  }
  _getColorWriteMask(material) {
    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
  }
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case NeverDepth:
          depthCompare = GPUCompareFunction.Never;
          break;
        case AlwaysDepth:
          depthCompare = GPUCompareFunction.Always;
          break;
        case LessDepth:
          depthCompare = GPUCompareFunction.Less;
          break;
        case LessEqualDepth:
          depthCompare = GPUCompareFunction.LessEqual;
          break;
        case EqualDepth:
          depthCompare = GPUCompareFunction.Equal;
          break;
        case GreaterEqualDepth:
          depthCompare = GPUCompareFunction.GreaterEqual;
          break;
        case GreaterDepth:
          depthCompare = GPUCompareFunction.Greater;
          break;
        case NotEqualDepth:
          depthCompare = GPUCompareFunction.NotEqual;
          break;
        default:
          console.error("THREE.WebGPURenderer: Invalid depth function.", depthFunc);
      }
    }
    return depthCompare;
  }
  _getPrimitiveState(object, geometry, material) {
    const descriptor = {};
    descriptor.topology = this._utils.getPrimitiveTopology(object, material);
    if (object.isLine === true && object.isLineSegments !== true) {
      const count = geometry.index ? geometry.index.count : geometry.attributes.position.count;
      descriptor.stripIndexFormat = count > 65535 ? GPUIndexFormat.Uint32 : GPUIndexFormat.Uint16;
    }
    switch (material.side) {
      case FrontSide:
        descriptor.frontFace = GPUFrontFace.CW;
        descriptor.cullMode = GPUCullMode.Front;
        break;
      case BackSide:
        descriptor.frontFace = GPUFrontFace.CW;
        descriptor.cullMode = GPUCullMode.Back;
        break;
      case DoubleSide:
        descriptor.frontFace = GPUFrontFace.CW;
        descriptor.cullMode = GPUCullMode.None;
        break;
      default:
        console.error("THREE.WebGPURenderer: Unknown Material.side value.", material.side);
        break;
    }
    return descriptor;
  }
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case NeverStencilFunc:
        stencilCompare = GPUCompareFunction.Never;
        break;
      case AlwaysStencilFunc:
        stencilCompare = GPUCompareFunction.Always;
        break;
      case LessStencilFunc:
        stencilCompare = GPUCompareFunction.Less;
        break;
      case LessEqualStencilFunc:
        stencilCompare = GPUCompareFunction.LessEqual;
        break;
      case EqualStencilFunc:
        stencilCompare = GPUCompareFunction.Equal;
        break;
      case GreaterEqualStencilFunc:
        stencilCompare = GPUCompareFunction.GreaterEqual;
        break;
      case GreaterStencilFunc:
        stencilCompare = GPUCompareFunction.Greater;
        break;
      case NotEqualStencilFunc:
        stencilCompare = GPUCompareFunction.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", stencilFunc);
    }
    return stencilCompare;
  }
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case KeepStencilOp:
        stencilOperation = GPUStencilOperation.Keep;
        break;
      case ZeroStencilOp:
        stencilOperation = GPUStencilOperation.Zero;
        break;
      case ReplaceStencilOp:
        stencilOperation = GPUStencilOperation.Replace;
        break;
      case InvertStencilOp:
        stencilOperation = GPUStencilOperation.Invert;
        break;
      case IncrementStencilOp:
        stencilOperation = GPUStencilOperation.IncrementClamp;
        break;
      case DecrementStencilOp:
        stencilOperation = GPUStencilOperation.DecrementClamp;
        break;
      case IncrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.IncrementWrap;
        break;
      case DecrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", stencilOperation);
    }
    return stencilOperation;
  }
  _getVertexFormat(geometryAttribute) {
    const { itemSize, normalized } = geometryAttribute;
    const ArrayType = geometryAttribute.array.constructor;
    const AttributeType = geometryAttribute.constructor;
    let format;
    if (itemSize == 1) {
      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
    } else {
      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);
      const prefix = prefixOptions[normalized ? 1 : 0];
      if (prefix) {
        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
        if (paddedItemSize % 1) {
          throw new Error("THREE.WebGPURenderer: Bad vertex format item size.");
        }
        format = `${prefix}x${paddedItemSize}`;
      }
    }
    if (!format) {
      console.error("THREE.WebGPURenderer: Vertex format not supported yet.");
    }
    return format;
  }
  _getShaderAttributes(nodeBuilder, geometry) {
    const nodeAttributes = nodeBuilder.attributes;
    const attributes = [];
    for (let slot = 0; slot < nodeAttributes.length; slot++) {
      const nodeAttribute = nodeAttributes[slot];
      const name = nodeAttribute.name;
      const geometryAttribute = geometry.getAttribute(name);
      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
      const format = this._getVertexFormat(geometryAttribute);
      let arrayStride = geometryAttribute.itemSize * bytesPerElement;
      let offset = 0;
      if (geometryAttribute.isInterleavedBufferAttribute === true) {
        arrayStride = geometryAttribute.data.stride * bytesPerElement;
        offset = geometryAttribute.offset * bytesPerElement;
      }
      attributes.push({
        name,
        arrayStride,
        offset,
        format,
        slot
      });
    }
    return attributes;
  }
};
var WebGPURenderPipeline_default = WebGPURenderPipeline;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUProgrammableStage.js
var _id = 0;
var WebGPUProgrammableStage = class {
  constructor(device, code, type) {
    this.id = _id++;
    this.code = code;
    this.type = type;
    this.usedTimes = 0;
    this.stage = {
      module: device.createShaderModule({ code, label: type }),
      entryPoint: "main"
    };
  }
};
var WebGPUProgrammableStage_default = WebGPUProgrammableStage;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderPipelines.js
var WebGPURenderPipelines = class {
  constructor(device, nodes, utils) {
    this.device = device;
    this.nodes = nodes;
    this.utils = utils;
    this.bindings = null;
    this.pipelines = [];
    this.cache = /* @__PURE__ */ new WeakMap();
    this.stages = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map()
    };
  }
  get(renderObject) {
    const device = this.device;
    const cache = this._getCache(renderObject);
    let currentPipeline = cache.currentPipeline;
    if (this._needsUpdate(renderObject)) {
      this._releasePipeline(renderObject);
      const nodeBuilder = this.nodes.get(renderObject);
      let stageVertex = this.stages.vertex.get(nodeBuilder.vertexShader);
      if (stageVertex === void 0) {
        stageVertex = new WebGPUProgrammableStage_default(device, nodeBuilder.vertexShader, "vertex");
        this.stages.vertex.set(nodeBuilder.vertexShader, stageVertex);
      }
      let stageFragment = this.stages.fragment.get(nodeBuilder.fragmentShader);
      if (stageFragment === void 0) {
        stageFragment = new WebGPUProgrammableStage_default(device, nodeBuilder.fragmentShader, "fragment");
        this.stages.fragment.set(nodeBuilder.fragmentShader, stageFragment);
      }
      currentPipeline = this._acquirePipeline(stageVertex, stageFragment, renderObject);
      cache.currentPipeline = currentPipeline;
      currentPipeline.usedTimes++;
      stageVertex.usedTimes++;
      stageFragment.usedTimes++;
    }
    return currentPipeline;
  }
  remove(renderObject) {
    this._releasePipeline(renderObject);
  }
  dispose() {
    this.pipelines = [];
    this.cache = /* @__PURE__ */ new WeakMap();
    this.shaderModules = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map()
    };
  }
  _acquirePipeline(stageVertex, stageFragment, renderObject) {
    let pipeline;
    const pipelines = this.pipelines;
    const cacheKey = this._computeCacheKey(stageVertex, stageFragment, renderObject);
    for (let i = 0, il = pipelines.length; i < il; i++) {
      const preexistingPipeline = pipelines[i];
      if (preexistingPipeline.cacheKey === cacheKey) {
        pipeline = preexistingPipeline;
        break;
      }
    }
    if (pipeline === void 0) {
      pipeline = new WebGPURenderPipeline_default(this.device, this.utils);
      pipeline.init(cacheKey, stageVertex, stageFragment, renderObject, this.nodes.get(renderObject));
      pipelines.push(pipeline);
    }
    return pipeline;
  }
  _computeCacheKey(stageVertex, stageFragment, renderObject) {
    const { object, material } = renderObject;
    const utils = this.utils;
    const parameters = [
      stageVertex.id,
      stageFragment.id,
      material.transparent,
      material.blending,
      material.premultipliedAlpha,
      material.blendSrc,
      material.blendDst,
      material.blendEquation,
      material.blendSrcAlpha,
      material.blendDstAlpha,
      material.blendEquationAlpha,
      material.colorWrite,
      material.depthWrite,
      material.depthTest,
      material.depthFunc,
      material.stencilWrite,
      material.stencilFunc,
      material.stencilFail,
      material.stencilZFail,
      material.stencilZPass,
      material.stencilFuncMask,
      material.stencilWriteMask,
      material.side,
      utils.getSampleCount(),
      utils.getCurrentColorSpace(),
      utils.getCurrentColorFormat(),
      utils.getCurrentDepthStencilFormat(),
      utils.getPrimitiveTopology(object, material)
    ];
    return parameters.join();
  }
  _getCache(renderObject) {
    let cache = this.cache.get(renderObject);
    if (cache === void 0) {
      cache = {};
      this.cache.set(renderObject, cache);
    }
    return cache;
  }
  _releasePipeline(renderObject) {
    const cache = this._getCache(renderObject);
    const pipeline = cache.currentPipeline;
    delete cache.currentPipeline;
    this.bindings.remove(renderObject);
    if (pipeline && --pipeline.usedTimes === 0) {
      const pipelines = this.pipelines;
      const i = pipelines.indexOf(pipeline);
      pipelines[i] = pipelines[pipelines.length - 1];
      pipelines.pop();
      this._releaseStage(pipeline.stageVertex);
      this._releaseStage(pipeline.stageFragment);
    }
  }
  _releaseStage(stage) {
    if (--stage.usedTimes === 0) {
      const code = stage.code;
      const type = stage.type;
      this.stages[type].delete(code);
    }
  }
  _needsUpdate(renderObject) {
    const cache = this._getCache(renderObject);
    const material = renderObject.material;
    let needsUpdate = false;
    if (cache.currentPipeline === void 0)
      needsUpdate = true;
    if (cache.material !== material || cache.materialVersion !== material.version || cache.transparent !== material.transparent || cache.blending !== material.blending || cache.premultipliedAlpha !== material.premultipliedAlpha || cache.blendSrc !== material.blendSrc || cache.blendDst !== material.blendDst || cache.blendEquation !== material.blendEquation || cache.blendSrcAlpha !== material.blendSrcAlpha || cache.blendDstAlpha !== material.blendDstAlpha || cache.blendEquationAlpha !== material.blendEquationAlpha || cache.colorWrite !== material.colorWrite || cache.depthWrite !== material.depthWrite || cache.depthTest !== material.depthTest || cache.depthFunc !== material.depthFunc || cache.stencilWrite !== material.stencilWrite || cache.stencilFunc !== material.stencilFunc || cache.stencilFail !== material.stencilFail || cache.stencilZFail !== material.stencilZFail || cache.stencilZPass !== material.stencilZPass || cache.stencilFuncMask !== material.stencilFuncMask || cache.stencilWriteMask !== material.stencilWriteMask || cache.side !== material.side) {
      cache.material = material;
      cache.materialVersion = material.version;
      cache.transparent = material.transparent;
      cache.blending = material.blending;
      cache.premultipliedAlpha = material.premultipliedAlpha;
      cache.blendSrc = material.blendSrc;
      cache.blendDst = material.blendDst;
      cache.blendEquation = material.blendEquation;
      cache.blendSrcAlpha = material.blendSrcAlpha;
      cache.blendDstAlpha = material.blendDstAlpha;
      cache.blendEquationAlpha = material.blendEquationAlpha;
      cache.colorWrite = material.colorWrite;
      cache.depthWrite = material.depthWrite;
      cache.depthTest = material.depthTest;
      cache.depthFunc = material.depthFunc;
      cache.stencilWrite = material.stencilWrite;
      cache.stencilFunc = material.stencilFunc;
      cache.stencilFail = material.stencilFail;
      cache.stencilZFail = material.stencilZFail;
      cache.stencilZPass = material.stencilZPass;
      cache.stencilFuncMask = material.stencilFuncMask;
      cache.stencilWriteMask = material.stencilWriteMask;
      cache.side = material.side;
      needsUpdate = true;
    }
    const utils = this.utils;
    const sampleCount = utils.getSampleCount();
    const colorSpace = utils.getCurrentColorSpace();
    const colorFormat = utils.getCurrentColorFormat();
    const depthStencilFormat = utils.getCurrentDepthStencilFormat();
    if (cache.sampleCount !== sampleCount || cache.colorSpace !== colorSpace || cache.colorFormat !== colorFormat || cache.depthStencilFormat !== depthStencilFormat) {
      cache.sampleCount = sampleCount;
      cache.colorSpace = colorSpace;
      cache.colorFormat = colorFormat;
      cache.depthStencilFormat = depthStencilFormat;
      needsUpdate = true;
    }
    return needsUpdate;
  }
};
var WebGPURenderPipelines_default = WebGPURenderPipelines;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUComputePipelines.js
var WebGPUComputePipelines = class {
  constructor(device, nodes) {
    this.device = device;
    this.nodes = nodes;
    this.pipelines = /* @__PURE__ */ new WeakMap();
    this.stages = {
      compute: /* @__PURE__ */ new WeakMap()
    };
  }
  has(computeNode) {
    return this.pipelines.get(computeNode) !== void 0;
  }
  get(computeNode) {
    let pipeline = this.pipelines.get(computeNode);
    if (pipeline === void 0) {
      const device = this.device;
      const nodeBuilder = this.nodes.getForCompute(computeNode);
      const computeShader = nodeBuilder.computeShader;
      const shader = {
        computeShader
      };
      let stageCompute = this.stages.compute.get(shader);
      if (stageCompute === void 0) {
        stageCompute = new WebGPUProgrammableStage_default(device, computeShader, "compute");
        this.stages.compute.set(shader, stageCompute);
      }
      pipeline = device.createComputePipeline({
        compute: stageCompute.stage,
        layout: "auto"
      });
      this.pipelines.set(computeNode, pipeline);
    }
    return pipeline;
  }
  dispose() {
    this.pipelines = /* @__PURE__ */ new WeakMap();
    this.stages = {
      compute: /* @__PURE__ */ new WeakMap()
    };
  }
};
var WebGPUComputePipelines_default = WebGPUComputePipelines;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBindings.js
var WebGPUBindings = class {
  constructor(device, info, properties, textures, renderPipelines, computePipelines, attributes, nodes) {
    this.device = device;
    this.info = info;
    this.properties = properties;
    this.textures = textures;
    this.renderPipelines = renderPipelines;
    this.computePipelines = computePipelines;
    this.attributes = attributes;
    this.nodes = nodes;
    this.uniformsData = /* @__PURE__ */ new WeakMap();
    this.updateMap = /* @__PURE__ */ new WeakMap();
  }
  get(renderObject) {
    let data = this.uniformsData.get(renderObject);
    if (data === void 0) {
      const nodeBuilder = this.nodes.get(renderObject);
      const bindings = nodeBuilder.getBindings();
      const pipeline = this.renderPipelines.get(renderObject).pipeline;
      const bindLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this._createBindGroup(bindings, bindLayout);
      data = {
        layout: bindLayout,
        group: bindGroup,
        bindings
      };
      this.uniformsData.set(renderObject, data);
    }
    return data;
  }
  getForCompute(computeNode) {
    let data = this.uniformsData.get(computeNode);
    if (data === void 0) {
      const nodeBuilder = this.nodes.getForCompute(computeNode);
      const bindings = nodeBuilder.getBindings();
      const pipeline = this.computePipelines.get(computeNode);
      const bindLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this._createBindGroup(bindings, bindLayout);
      data = {
        layout: bindLayout,
        group: bindGroup,
        bindings
      };
      this.uniformsData.set(computeNode, data);
    }
    return data;
  }
  remove(object) {
    this.uniformsData.delete(object);
  }
  update(object) {
    const textures = this.textures;
    const data = this.get(object);
    const bindings = data.bindings;
    const updateMap = this.updateMap;
    const frame = this.info.render.frame;
    let needsBindGroupRefresh = false;
    for (const binding of bindings) {
      const isShared = binding.isShared;
      const isUpdated = updateMap.get(binding) === frame;
      if (isShared && isUpdated)
        continue;
      if (binding.isUniformBuffer) {
        const buffer = binding.getBuffer();
        const needsBufferWrite = binding.update();
        if (needsBufferWrite === true) {
          const bufferGPU = binding.bufferGPU;
          this.device.queue.writeBuffer(bufferGPU, 0, buffer, 0);
        }
      } else if (binding.isStorageBuffer) {
        const attribute = binding.attribute;
        this.attributes.update(attribute, false, binding.usage);
      } else if (binding.isSampler) {
        const texture2 = binding.getTexture();
        textures.updateSampler(texture2);
        const samplerGPU = textures.getSampler(texture2);
        if (binding.samplerGPU !== samplerGPU) {
          binding.samplerGPU = samplerGPU;
          needsBindGroupRefresh = true;
        }
      } else if (binding.isSampledTexture) {
        const texture2 = binding.getTexture();
        const needsTextureRefresh = textures.updateTexture(texture2);
        const textureGPU = textures.getTextureGPU(texture2);
        if (textureGPU !== void 0 && binding.textureGPU !== textureGPU || needsTextureRefresh === true) {
          binding.textureGPU = textureGPU;
          needsBindGroupRefresh = true;
        }
      }
      updateMap.set(binding, frame);
    }
    if (needsBindGroupRefresh === true) {
      data.group = this._createBindGroup(bindings, data.layout);
    }
  }
  dispose() {
    this.uniformsData = /* @__PURE__ */ new WeakMap();
    this.updateMap = /* @__PURE__ */ new WeakMap();
  }
  _createBindGroup(bindings, layout) {
    let bindingPoint = 0;
    const entries = [];
    for (const binding of bindings) {
      if (binding.isUniformBuffer) {
        if (binding.bufferGPU === null) {
          const byteLength = binding.getByteLength();
          binding.bufferGPU = this.device.createBuffer({
            label: "bindingBuffer",
            size: byteLength,
            usage: binding.usage
          });
        }
        entries.push({ binding: bindingPoint, resource: { buffer: binding.bufferGPU } });
      } else if (binding.isStorageBuffer) {
        if (binding.bufferGPU === null) {
          const attribute = binding.attribute;
          this.attributes.update(attribute, false, binding.usage);
          binding.bufferGPU = this.attributes.get(attribute).buffer;
        }
        entries.push({ binding: bindingPoint, resource: { buffer: binding.bufferGPU } });
      } else if (binding.isSampler) {
        if (binding.samplerGPU === null) {
          binding.samplerGPU = this.textures.getDefaultSampler();
        }
        entries.push({ binding: bindingPoint, resource: binding.samplerGPU });
      } else if (binding.isSampledTexture) {
        if (binding.textureGPU === null) {
          if (binding.isSampledCubeTexture) {
            binding.textureGPU = this.textures.getDefaultCubeTexture();
          } else if (binding.texture.isVideoTexture) {
            binding.textureGPU = this.textures.getDefaultVideoTexture();
          } else if (binding.texture.isDepthTexture) {
            binding.textureGPU = this.textures.getDefaultDepthTexture();
          } else {
            binding.textureGPU = this.textures.getDefaultTexture();
          }
        }
        const resource = binding.textureGPU instanceof GPUTexture ? binding.textureGPU.createView({ aspect: binding.aspect, dimension: binding.dimension }) : binding.textureGPU;
        entries.push({ binding: bindingPoint, resource });
      }
      bindingPoint++;
    }
    return this.device.createBindGroup({
      layout,
      entries
    });
  }
};
var WebGPUBindings_default = WebGPUBindings;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderLists.js
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
var WebGPURenderList = class {
  constructor() {
    this.renderItems = [];
    this.renderItemsIndex = 0;
    this.opaque = [];
    this.transparent = [];
    this.lightsNode = lights([]);
    this.lightsArray = [];
  }
  init() {
    this.renderItemsIndex = 0;
    this.opaque.length = 0;
    this.transparent.length = 0;
    this.lightsArray.length = 0;
    return this;
  }
  getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = this.renderItems[this.renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      this.renderItems[this.renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    this.renderItemsIndex++;
    return renderItem;
  }
  push(object, geometry, material, groupOrder, z, group) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? this.transparent : this.opaque).push(renderItem);
  }
  unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? this.transparent : this.opaque).unshift(renderItem);
  }
  pushLight(light) {
    this.lightsArray.push(light);
  }
  getLightsNode() {
    return this.lightsNode.fromLights(this.lightsArray);
  }
  sort(customOpaqueSort, customTransparentSort) {
    if (this.opaque.length > 1)
      this.opaque.sort(customOpaqueSort || painterSortStable);
    if (this.transparent.length > 1)
      this.transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  finish() {
    this.lightsNode.fromLights(this.lightsArray);
    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
      const renderItem = this.renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
};
var WebGPURenderLists = class {
  constructor() {
    this.lists = /* @__PURE__ */ new WeakMap();
    this.lists = new WebGPUWeakMap();
  }
  get(scene, camera) {
    const lists = this.lists;
    const keys = [scene, camera];
    let list = lists.get(keys);
    if (list === void 0) {
      list = new WebGPURenderList();
      lists.set(keys, list);
    }
    return list;
  }
  dispose() {
    this.lists = /* @__PURE__ */ new WeakMap();
  }
};
var WebGPURenderLists_default = WebGPURenderLists;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderStates.js
var WebGPURenderState = class {
  constructor() {
    this.depth = true;
    this.stencil = true;
    this.descriptorGPU = null;
    this.encoderGPU = null;
    this.currentPassGPU = null;
  }
};
var WebGPURenderStates = class {
  constructor() {
    this.renderStates = new WebGPUWeakMap();
  }
  get(scene, camera) {
    const chainKey = [scene, camera];
    let renderState = this.renderStates.get(chainKey);
    if (renderState === void 0) {
      renderState = new WebGPURenderState();
      this.renderStates.set(chainKey, renderState);
    }
    return renderState;
  }
  dispose() {
    this.renderStates = new WebGPUWeakMap();
  }
};
var WebGPURenderStates_default = WebGPURenderStates;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUTextureUtils.js
var WebGPUTextureUtils = class {
  constructor(device) {
    this.device = device;
    const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
    const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
    this.sampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
    this.pipelines = {};
    this.mipmapVertexShaderModule = device.createShaderModule({
      label: "mipmapVertex",
      code: mipmapVertexSource
    });
    this.mipmapFragmentShaderModule = device.createShaderModule({
      label: "mipmapFragment",
      code: mipmapFragmentSource
    });
  }
  getMipmapPipeline(format) {
    let pipeline = this.pipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.mipmapFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.pipelines[format] = pipeline;
    }
    return pipeline;
  }
  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const pipeline = this.getMipmapPipeline(textureGPUDescriptor.format);
    const commandEncoder = this.device.createCommandEncoder({});
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    let srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
      const dstView = textureGPU.createView({
        baseMipLevel: i,
        mipLevelCount: 1,
        dimension: GPUTextureViewDimension.TwoD,
        baseArrayLayer
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: dstView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.sampler
        }, {
          binding: 1,
          resource: srcView
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
      srcView = dstView;
    }
    this.device.queue.submit([commandEncoder.finish()]);
  }
};
var WebGPUTextureUtils_default = WebGPUTextureUtils;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUTextures.js
var WebGPUTextures = class {
  constructor(device, properties, info) {
    this.device = device;
    this.properties = properties;
    this.info = info;
    this.defaultTexture = null;
    this.depthDefaultTexture = null;
    this.defaultVideoTexture = null;
    this.defaultCubeTexture = null;
    this.defaultSampler = null;
    this.samplerCache = /* @__PURE__ */ new Map();
    this.utils = null;
  }
  getDefaultSampler() {
    if (this.defaultSampler === null) {
      this.defaultSampler = this.device.createSampler({});
    }
    return this.defaultSampler;
  }
  getDefaultDepthTexture() {
    if (this.depthDefaultTexture === null) {
      const depthTexture = new DepthTexture();
      depthTexture.image.width = 1;
      depthTexture.image.height = 1;
      this._uploadTexture(depthTexture);
      this.depthDefaultTexture = this.getTextureGPU(depthTexture);
    }
    return this.depthDefaultTexture;
  }
  getDefaultTexture() {
    if (this.defaultTexture === null) {
      const texture2 = new Texture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this._uploadTexture(texture2);
      this.defaultTexture = this.getTextureGPU(texture2);
    }
    return this.defaultTexture;
  }
  getDefaultVideoTexture() {
    if (this.defaultVideoTexture === null) {
      const video = document.getElementById("video");
      const texture2 = new VideoTexture(video);
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this._uploadVideoTexture(texture2);
      this.defaultVideoTexture = this.getTextureGPU(texture2);
    }
    return this.defaultVideoTexture;
  }
  getDefaultCubeTexture() {
    if (this.defaultCubeTexture === null) {
      const texture2 = new CubeTexture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this._uploadTexture(texture2);
      this.defaultCubeTexture = this.getTextureGPU(texture2);
    }
    return this.defaultCubeTexture;
  }
  getTextureGPU(texture2) {
    const textureProperties = this.properties.get(texture2);
    return textureProperties.textureGPU;
  }
  getSampler(texture2) {
    const textureProperties = this.properties.get(texture2);
    return textureProperties.samplerGPU;
  }
  updateTexture(texture2) {
    let needsUpdate = false;
    const textureProperties = this.properties.get(texture2);
    if (texture2.version > 0 && textureProperties.version !== texture2.version) {
      const image = texture2.image;
      if (image === void 0) {
        console.warn("THREE.WebGPURenderer: Texture marked for update but image is undefined.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGPURenderer: Texture marked for update but image is incomplete.");
      } else {
        if (textureProperties.initialized === void 0) {
          textureProperties.initialized = true;
          const disposeCallback = onTextureDispose.bind(this);
          textureProperties.disposeCallback = disposeCallback;
          texture2.addEventListener("dispose", disposeCallback);
          this.info.memory.textures++;
        }
        if (texture2.isVideoTexture) {
          needsUpdate = this._uploadVideoTexture(texture2);
        } else {
          needsUpdate = this._uploadTexture(texture2);
        }
      }
    }
    if (textureProperties.initializedRTT === false) {
      textureProperties.initializedRTT = true;
      needsUpdate = true;
    }
    return needsUpdate;
  }
  updateSampler(texture2) {
    const array = [];
    array.push(texture2.wrapS);
    array.push(texture2.wrapT);
    array.push(texture2.wrapR);
    array.push(texture2.magFilter);
    array.push(texture2.minFilter);
    array.push(texture2.anisotropy);
    const key = array.join();
    let samplerGPU = this.samplerCache.get(key);
    if (samplerGPU === void 0) {
      samplerGPU = this.device.createSampler({
        addressModeU: this._convertAddressMode(texture2.wrapS),
        addressModeV: this._convertAddressMode(texture2.wrapT),
        addressModeW: this._convertAddressMode(texture2.wrapR),
        magFilter: this._convertFilterMode(texture2.magFilter),
        minFilter: this._convertFilterMode(texture2.minFilter),
        mipmapFilter: this._convertFilterMode(texture2.minFilter),
        maxAnisotropy: texture2.anisotropy
      });
      this.samplerCache.set(key, samplerGPU);
    }
    const textureProperties = this.properties.get(texture2);
    textureProperties.samplerGPU = samplerGPU;
  }
  initRenderTarget(renderTarget) {
    const properties = this.properties;
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTargetProperties.initialized === void 0) {
      const device = this.device;
      const width = renderTarget.width;
      const height = renderTarget.height;
      const texture2 = renderTarget.texture;
      const colorTextureFormat = texture2.internalFormat || this._getFormat(texture2);
      const label = texture2.name ? "_" + texture2.name : "";
      const needsMipmaps = this._needsMipmaps(texture2);
      const mipLevelCount = this._getMipLevelCount(texture2, width, height, needsMipmaps);
      const colorTextureGPU = device.createTexture({
        label: "renderTarget" + label,
        size: {
          width,
          height,
          depthOrArrayLayers: 1
        },
        mipLevelCount,
        format: colorTextureFormat,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      this.info.memory.textures++;
      renderTargetProperties.colorTextureGPU = colorTextureGPU;
      renderTargetProperties.colorTextureFormat = colorTextureFormat;
      const textureProperties = properties.get(texture2);
      textureProperties.textureGPU = colorTextureGPU;
      textureProperties.initializedRTT = false;
      if (renderTarget.depthBuffer === true) {
        const depthTextureFormat = renderTarget.depthTexture !== null ? this._getFormat(renderTarget.depthTexture) : GPUTextureFormat.Depth24PlusStencil8;
        const depthTextureGPU = device.createTexture({
          label: "renderTarget" + label + "_depthBuffer",
          size: {
            width,
            height,
            depthOrArrayLayers: 1
          },
          format: depthTextureFormat,
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
        });
        this.info.memory.textures++;
        renderTargetProperties.depthTextureGPU = depthTextureGPU;
        renderTargetProperties.depthTextureFormat = depthTextureFormat;
        if (renderTarget.depthTexture !== null) {
          const depthTextureProperties = properties.get(renderTarget.depthTexture);
          depthTextureProperties.textureGPU = depthTextureGPU;
          depthTextureProperties.initializedRTT = false;
        }
      }
      const disposeCallback = onRenderTargetDispose.bind(this);
      renderTargetProperties.disposeCallback = disposeCallback;
      renderTarget.addEventListener("dispose", disposeCallback);
      renderTargetProperties.initialized = true;
    }
  }
  dispose() {
    this.samplerCache.clear();
  }
  _convertAddressMode(value) {
    let addressMode = GPUAddressMode.ClampToEdge;
    if (value === RepeatWrapping) {
      addressMode = GPUAddressMode.Repeat;
    } else if (value === MirroredRepeatWrapping) {
      addressMode = GPUAddressMode.MirrorRepeat;
    }
    return addressMode;
  }
  _convertFilterMode(value) {
    let filterMode = GPUFilterMode.Linear;
    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {
      filterMode = GPUFilterMode.Nearest;
    }
    return filterMode;
  }
  _uploadVideoTexture(texture2) {
    const device = this.device;
    const textureProperties = this.properties.get(texture2);
    const textureGPU = device.importExternalTexture({
      source: texture2.source.data
    });
    textureProperties.textureGPU = textureGPU;
    return true;
  }
  _uploadTexture(texture2) {
    let needsUpdate = false;
    const device = this.device;
    const image = texture2.image;
    const textureProperties = this.properties.get(texture2);
    const { width, height, depth } = this._getSize(texture2);
    const needsMipmaps = this._needsMipmaps(texture2);
    const dimension = this._getDimension(texture2);
    const mipLevelCount = this._getMipLevelCount(texture2, width, height, needsMipmaps);
    const format = texture2.internalFormat || this._getFormat(texture2);
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    if (needsMipmaps) {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    }
    const textureGPUDescriptor = {
      label: texture2.name,
      size: {
        width,
        height,
        depthOrArrayLayers: depth
      },
      mipLevelCount,
      sampleCount: 1,
      dimension,
      format,
      usage
    };
    let textureGPU = textureProperties.textureGPU;
    if (textureGPU === void 0) {
      textureGPU = device.createTexture(textureGPUDescriptor);
      needsUpdate = true;
    }
    if (texture2.isDataTexture || texture2.isDataArrayTexture || texture2.isData3DTexture) {
      this._copyBufferToTexture(image, textureGPU, textureGPUDescriptor, needsMipmaps);
    } else if (texture2.isCompressedTexture) {
      this._copyCompressedBufferToTexture(texture2.mipmaps, textureGPU, textureGPUDescriptor);
    } else if (texture2.isCubeTexture) {
      if (image.length === 6) {
        this._copyCubeMapToTexture(image, texture2, textureGPU, textureGPUDescriptor, needsMipmaps);
      }
    } else if (texture2.isRenderTargetTexture) {
      if (needsMipmaps === true)
        this._generateMipmaps(textureGPU, textureGPUDescriptor);
    } else if (texture2.isDepthTexture !== true && image !== null) {
      this._copyImageToTexture(image, texture2, textureGPU, textureGPUDescriptor, needsMipmaps);
    }
    textureProperties.textureGPU = textureGPU;
    textureProperties.version = texture2.version;
    return needsUpdate;
  }
  _copyBufferToTexture(image, textureGPU, textureGPUDescriptor, needsMipmaps, originDepth = 0) {
    const data = image.data;
    const bytesPerTexel = this._getBytesPerTexel(textureGPUDescriptor.format);
    const bytesPerRow = image.width * bytesPerTexel;
    this.device.queue.writeTexture(
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth }
      },
      data,
      {
        offset: 0,
        bytesPerRow
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: image.depth !== void 0 ? image.depth : 1
      }
    );
    if (needsMipmaps === true)
      this._generateMipmaps(textureGPU, textureGPUDescriptor, originDepth);
  }
  _copyCubeMapToTexture(images, texture2, textureGPU, textureGPUDescriptor, needsMipmaps) {
    for (let i = 0; i < 6; i++) {
      const image = images[i];
      if (image.isDataTexture) {
        this._copyBufferToTexture(image.image, textureGPU, textureGPUDescriptor, needsMipmaps, i);
      } else {
        this._copyImageToTexture(image, texture2, textureGPU, textureGPUDescriptor, needsMipmaps, i);
      }
    }
  }
  _copyExternalImageToTexture(image, textureGPU, textureGPUDescriptor, needsMipmaps, originDepth = 0) {
    this.device.queue.copyExternalImageToTexture(
      {
        source: image
      },
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth }
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (needsMipmaps)
      this._generateMipmaps(textureGPU, textureGPUDescriptor, originDepth);
  }
  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureGPUDescriptor) {
    const blockData = this._getBlockData(textureGPUDescriptor.format);
    for (let i = 0; i < mipmaps.length; i++) {
      const mipmap = mipmaps[i];
      const width = mipmap.width;
      const height = mipmap.height;
      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
      this.device.queue.writeTexture(
        {
          texture: textureGPU,
          mipLevel: i
        },
        mipmap.data,
        {
          offset: 0,
          bytesPerRow
        },
        {
          width: Math.ceil(width / blockData.width) * blockData.width,
          height: Math.ceil(height / blockData.width) * blockData.width,
          depthOrArrayLayers: 1
        }
      );
    }
  }
  _generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer) {
    if (this.utils === null) {
      this.utils = new WebGPUTextureUtils_default(this.device);
    }
    this.utils.generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer);
  }
  _getBlockData(format) {
    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Unorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Snorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Unorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Snorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB)
      return { byteLength: 16, width: 5, height: 4 };
    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB)
      return { byteLength: 16, width: 5, height: 5 };
    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB)
      return { byteLength: 16, width: 6, height: 5 };
    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB)
      return { byteLength: 16, width: 6, height: 6 };
    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB)
      return { byteLength: 16, width: 8, height: 5 };
    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB)
      return { byteLength: 16, width: 8, height: 6 };
    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB)
      return { byteLength: 16, width: 8, height: 8 };
    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB)
      return { byteLength: 16, width: 10, height: 5 };
    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB)
      return { byteLength: 16, width: 10, height: 6 };
    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB)
      return { byteLength: 16, width: 10, height: 8 };
    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB)
      return { byteLength: 16, width: 10, height: 10 };
    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB)
      return { byteLength: 16, width: 12, height: 10 };
    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB)
      return { byteLength: 16, width: 12, height: 12 };
  }
  _getBytesPerTexel(format) {
    if (format === GPUTextureFormat.R8Unorm)
      return 1;
    if (format === GPUTextureFormat.R16Float)
      return 2;
    if (format === GPUTextureFormat.RG8Unorm)
      return 2;
    if (format === GPUTextureFormat.RG16Float)
      return 4;
    if (format === GPUTextureFormat.R32Float)
      return 4;
    if (format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB)
      return 4;
    if (format === GPUTextureFormat.RG32Float)
      return 8;
    if (format === GPUTextureFormat.RGBA16Float)
      return 8;
    if (format === GPUTextureFormat.RGBA32Float)
      return 16;
  }
  _getDimension(texture2) {
    let dimension;
    if (texture2.isData3DTexture) {
      dimension = GPUTextureDimension.ThreeD;
    } else {
      dimension = GPUTextureDimension.TwoD;
    }
    return dimension;
  }
  _getFormat(texture2) {
    const format = texture2.format;
    const type = texture2.type;
    const colorSpace = texture2.colorSpace;
    let formatGPU;
    if (texture2.isCompressedTexture === true) {
      switch (format) {
        case RGBA_S3TC_DXT1_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
          break;
        case RGBA_S3TC_DXT3_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
          break;
        case RGBA_S3TC_DXT5_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
          break;
        case RGB_ETC2_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
          break;
        case RGBA_ETC2_EAC_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
          break;
        case RGBA_ASTC_4x4_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
          break;
        case RGBA_ASTC_5x4_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
          break;
        case RGBA_ASTC_5x5_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
          break;
        case RGBA_ASTC_6x5_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
          break;
        case RGBA_ASTC_6x6_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
          break;
        case RGBA_ASTC_8x5_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
          break;
        case RGBA_ASTC_8x6_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
          break;
        case RGBA_ASTC_8x8_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
          break;
        case RGBA_ASTC_10x5_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
          break;
        case RGBA_ASTC_10x6_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
          break;
        case RGBA_ASTC_10x8_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
          break;
        case RGBA_ASTC_10x10_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
          break;
        case RGBA_ASTC_12x10_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
          break;
        case RGBA_ASTC_12x12_Format:
          formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
          break;
        default:
          console.error("WebGPURenderer: Unsupported texture format.", format);
      }
    } else {
      switch (format) {
        case RGBAFormat:
          switch (type) {
            case UnsignedByteType:
              formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
              break;
            case HalfFloatType:
              formatGPU = GPUTextureFormat.RGBA16Float;
              break;
            case FloatType:
              formatGPU = GPUTextureFormat.RGBA32Float;
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", type);
          }
          break;
        case RedFormat:
          switch (type) {
            case UnsignedByteType:
              formatGPU = GPUTextureFormat.R8Unorm;
              break;
            case HalfFloatType:
              formatGPU = GPUTextureFormat.R16Float;
              break;
            case FloatType:
              formatGPU = GPUTextureFormat.R32Float;
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture type with RedFormat.", type);
          }
          break;
        case RGFormat:
          switch (type) {
            case UnsignedByteType:
              formatGPU = GPUTextureFormat.RG8Unorm;
              break;
            case HalfFloatType:
              formatGPU = GPUTextureFormat.RG16Float;
              break;
            case FloatType:
              formatGPU = GPUTextureFormat.RG32Float;
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture type with RGFormat.", type);
          }
          break;
        case DepthFormat:
          switch (type) {
            case UnsignedShortType:
              formatGPU = GPUTextureFormat.Depth16Unorm;
              break;
            case UnsignedIntType:
              formatGPU = GPUTextureFormat.Depth24Plus;
              break;
            case FloatType:
              formatGPU = GPUTextureFormat.Depth32Float;
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", type);
          }
          break;
        case DepthStencilFormat:
          switch (type) {
            case UnsignedInt248Type:
              formatGPU = GPUTextureFormat.Depth24PlusStencil8;
              break;
            case FloatType:
              if (this.device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
                console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
              }
              formatGPU = GPUTextureFormat.Depth32FloatStencil8;
              break;
            default:
              console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", type);
          }
          break;
        default:
          console.error("WebGPURenderer: Unsupported texture format.", format);
      }
    }
    return formatGPU;
  }
  _isHTMLImage(image) {
    return typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement;
  }
  _copyImageToTexture(image, texture2, textureGPU, textureGPUDescriptor, needsMipmaps, originDepth) {
    if (this._isHTMLImage(image)) {
      this._getImageBitmapFromHTML(image, texture2).then((imageBitmap) => {
        this._copyExternalImageToTexture(imageBitmap, textureGPU, textureGPUDescriptor, needsMipmaps, originDepth);
      });
    } else {
      this._copyExternalImageToTexture(image, textureGPU, textureGPUDescriptor, needsMipmaps, originDepth);
    }
  }
  _getImageBitmapFromHTML(image, texture2) {
    const width = image.width;
    const height = image.height;
    const options = {};
    options.imageOrientation = texture2.flipY === true ? "flipY" : "none";
    options.premultiplyAlpha = texture2.premultiplyAlpha === true ? "premultiply" : "default";
    return createImageBitmap(image, 0, 0, width, height, options);
  }
  _getImageBitmap(image, texture2) {
    const width = image.width;
    const height = image.height;
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement) {
      const options = {};
      options.imageOrientation = texture2.flipY === true ? "flipY" : "none";
      options.premultiplyAlpha = texture2.premultiplyAlpha === true ? "premultiply" : "default";
      return createImageBitmap(image, 0, 0, width, height, options);
    } else {
      return Promise.resolve(image);
    }
  }
  _getMipLevelCount(texture2, width, height, needsMipmaps) {
    let mipLevelCount;
    if (texture2.isCompressedTexture) {
      mipLevelCount = texture2.mipmaps.length;
    } else if (needsMipmaps) {
      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
    } else {
      mipLevelCount = 1;
    }
    return mipLevelCount;
  }
  _getSize(texture2) {
    const image = texture2.image;
    let width, height, depth;
    if (texture2.isCubeTexture) {
      const faceImage = image.length > 0 ? image[0].image || image[0] : null;
      width = faceImage ? faceImage.width : 1;
      height = faceImage ? faceImage.height : 1;
      depth = 6;
    } else if (image !== null) {
      width = image.width;
      height = image.height;
      depth = image.depth !== void 0 ? image.depth : 1;
    } else {
      width = height = depth = 1;
    }
    return { width, height, depth };
  }
  _needsMipmaps(texture2) {
    return texture2.isCompressedTexture !== true && texture2.generateMipmaps === true && texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter;
  }
};
function onRenderTargetDispose(event) {
  const renderTarget = event.target;
  const properties = this.properties;
  const renderTargetProperties = properties.get(renderTarget);
  renderTarget.removeEventListener("dispose", renderTargetProperties.disposeCallback);
  renderTargetProperties.colorTextureGPU.destroy();
  properties.remove(renderTarget.texture);
  this.info.memory.textures--;
  if (renderTarget.depthBuffer === true) {
    renderTargetProperties.depthTextureGPU.destroy();
    this.info.memory.textures--;
    if (renderTarget.depthTexture !== null) {
      properties.remove(renderTarget.depthTexture);
    }
  }
  properties.remove(renderTarget);
}
function onTextureDispose(event) {
  const texture2 = event.target;
  const textureProperties = this.properties.get(texture2);
  textureProperties.textureGPU.destroy();
  texture2.removeEventListener("dispose", textureProperties.disposeCallback);
  this.properties.remove(texture2);
  this.info.memory.textures--;
}
var WebGPUTextures_default = WebGPUTextures;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBackground.js
var _clearAlpha;
var _clearColor = new Color();
var WebGPUBackground = class {
  constructor(renderer, properties) {
    this.renderer = renderer;
    this.properties = properties;
    this.boxMesh = null;
    this.boxMeshNode = null;
    this.forceClear = false;
  }
  clear() {
    this.forceClear = true;
  }
  update(scene, renderList, renderState) {
    const renderer = this.renderer;
    const background = scene.isScene === true ? scene.backgroundNode || this.properties.get(scene).backgroundNode || scene.background : null;
    let forceClear = this.forceClear;
    if (background === null) {
      _clearColor.copy(renderer._clearColor);
      _clearAlpha = renderer._clearAlpha;
    } else if (background.isColor === true) {
      _clearColor.copy(background);
      _clearAlpha = 1;
      forceClear = true;
    } else if (background.isNode === true) {
      const sceneProperties = this.properties.get(scene);
      const backgroundNode = background;
      _clearColor.copy(renderer._clearColor);
      _clearAlpha = renderer._clearAlpha;
      let boxMesh = this.boxMesh;
      if (boxMesh === null) {
        this.boxMeshNode = context(backgroundNode, {
          // @TODO: Add Texture2D support using node context
          getUVNode: () => positionWorldDirection
        });
        const nodeMaterial = new MeshBasicNodeMaterial_default();
        nodeMaterial.colorNode = this.boxMeshNode;
        nodeMaterial.side = BackSide;
        nodeMaterial.depthTest = false;
        nodeMaterial.depthWrite = false;
        nodeMaterial.fog = false;
        this.boxMesh = boxMesh = new Mesh(new BoxGeometry(1, 1, 1), nodeMaterial);
        boxMesh.frustumCulled = false;
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          const scale = camera.far;
          this.matrixWorld.makeScale(scale, scale, scale).copyPosition(camera.matrixWorld);
        };
      }
      const backgroundCacheKey = backgroundNode.getCacheKey();
      if (sceneProperties.backgroundCacheKey !== backgroundCacheKey) {
        this.boxMeshNode.node = backgroundNode;
        boxMesh.material.needsUpdate = true;
        sceneProperties.backgroundCacheKey = backgroundCacheKey;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else {
      console.error("THREE.WebGPURenderer: Unsupported background configuration.", background);
    }
    const colorAttachment = renderState.descriptorGPU.colorAttachments[0];
    const depthStencilAttachment = renderState.descriptorGPU.depthStencilAttachment;
    if (renderer.autoClear === true || forceClear === true) {
      if (renderer.autoClearColor === true) {
        _clearColor.multiplyScalar(_clearAlpha);
        colorAttachment.clearValue = { r: _clearColor.r, g: _clearColor.g, b: _clearColor.b, a: _clearAlpha };
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      } else {
        colorAttachment.loadOp = GPULoadOp.Load;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
      if (renderState.depth) {
        if (renderer.autoClearDepth === true) {
          depthStencilAttachment.depthClearValue = renderer._clearDepth;
          depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
          depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
        } else {
          depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
          depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
        }
      }
      if (renderState.stencil) {
        if (renderer.autoClearStencil === true) {
          depthStencilAttachment.stencilClearValue = renderer._clearStencil;
          depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
          depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
        } else {
          depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
          depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
        }
      }
    } else {
      colorAttachment.loadOp = GPULoadOp.Load;
      colorAttachment.storeOp = GPUStoreOp.Store;
      if (renderState.depth) {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
      if (renderState.stencil) {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    this.forceClear = false;
  }
};
var WebGPUBackground_default = WebGPUBackground;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBinding.js
var WebGPUBinding = class {
  constructor(name = "") {
    this.name = name;
    this.visibility = null;
    this.type = null;
    this.isShared = false;
  }
  setVisibility(visibility) {
    this.visibility = visibility;
  }
};
var WebGPUBinding_default = WebGPUBinding;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBufferUtils.js
function getFloatLength(floatLength) {
  return floatLength + (GPUChunkSize - floatLength % GPUChunkSize) % GPUChunkSize;
}
function getVectorLength(count, vectorLength = 4) {
  const strideLength = getStrideLength(vectorLength);
  const floatLength = strideLength * count;
  return getFloatLength(floatLength);
}
function getStrideLength(vectorLength) {
  const strideLength = 4;
  return vectorLength + (strideLength - vectorLength % strideLength) % strideLength;
}

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBuffer.js
var WebGPUBuffer = class extends WebGPUBinding_default {
  constructor(name, type, buffer = null) {
    super(name);
    this.isBuffer = true;
    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
    this.type = type;
    this.visibility = GPUShaderStage.VERTEX;
    this.usage = GPUBufferUsage.COPY_DST;
    this.buffer = buffer;
    this.bufferGPU = null;
  }
  getByteLength() {
    return getFloatLength(this.buffer.byteLength);
  }
  getBuffer() {
    return this.buffer;
  }
  update() {
    return true;
  }
};
var WebGPUBuffer_default = WebGPUBuffer;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUUniformBuffer.js
var WebGPUUniformBuffer = class extends WebGPUBuffer_default {
  constructor(name, buffer = null) {
    super(name, GPUBindingType.UniformBuffer, buffer);
    this.isUniformBuffer = true;
    this.usage |= GPUBufferUsage.UNIFORM;
  }
};
var WebGPUUniformBuffer_default = WebGPUUniformBuffer;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUUniformsGroup.js
var WebGPUUniformsGroup = class extends WebGPUUniformBuffer_default {
  constructor(name) {
    super(name);
    this.isUniformsGroup = true;
    this.uniforms = [];
  }
  addUniform(uniform) {
    this.uniforms.push(uniform);
    return this;
  }
  removeUniform(uniform) {
    const index = this.uniforms.indexOf(uniform);
    if (index !== -1) {
      this.uniforms.splice(index, 1);
    }
    return this;
  }
  getBuffer() {
    let buffer = this.buffer;
    if (buffer === null) {
      const byteLength = this.getByteLength();
      buffer = new Float32Array(new ArrayBuffer(byteLength));
      this.buffer = buffer;
    }
    return buffer;
  }
  getByteLength() {
    let offset = 0;
    for (let i = 0, l = this.uniforms.length; i < l; i++) {
      const uniform = this.uniforms[i];
      const chunkOffset = offset % GPUChunkSize;
      const remainingSizeInChunk = GPUChunkSize - chunkOffset;
      if (chunkOffset !== 0 && remainingSizeInChunk - uniform.boundary < 0) {
        offset += GPUChunkSize - chunkOffset;
      } else if (chunkOffset % uniform.boundary !== 0) {
        offset += chunkOffset % uniform.boundary;
      }
      uniform.offset = offset / this.bytesPerElement;
      offset += uniform.itemSize * this.bytesPerElement;
    }
    return Math.ceil(offset / GPUChunkSize) * GPUChunkSize;
  }
  update() {
    let updated = false;
    for (const uniform of this.uniforms) {
      if (this.updateByType(uniform) === true) {
        updated = true;
      }
    }
    return updated;
  }
  updateByType(uniform) {
    if (uniform.isFloatUniform)
      return this.updateNumber(uniform);
    if (uniform.isVector2Uniform)
      return this.updateVector2(uniform);
    if (uniform.isVector3Uniform)
      return this.updateVector3(uniform);
    if (uniform.isVector4Uniform)
      return this.updateVector4(uniform);
    if (uniform.isColorUniform)
      return this.updateColor(uniform);
    if (uniform.isMatrix3Uniform)
      return this.updateMatrix3(uniform);
    if (uniform.isMatrix4Uniform)
      return this.updateMatrix4(uniform);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", uniform);
  }
  updateNumber(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset] !== v) {
      a[offset] = v;
      updated = true;
    }
    return updated;
  }
  updateVector2(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      updated = true;
    }
    return updated;
  }
  updateVector3(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      a[offset + 2] = v.z;
      updated = true;
    }
    return updated;
  }
  updateVector4(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      a[offset + 2] = v.z;
      a[offset + 3] = v.w;
      updated = true;
    }
    return updated;
  }
  updateColor(uniform) {
    let updated = false;
    const a = this.buffer;
    const c = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {
      a[offset + 0] = c.r;
      a[offset + 1] = c.g;
      a[offset + 2] = c.b;
      updated = true;
    }
    return updated;
  }
  updateMatrix3(uniform) {
    let updated = false;
    const a = this.buffer;
    const e = uniform.getValue().elements;
    const offset = uniform.offset;
    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {
      a[offset + 0] = e[0];
      a[offset + 1] = e[1];
      a[offset + 2] = e[2];
      a[offset + 4] = e[3];
      a[offset + 5] = e[4];
      a[offset + 6] = e[5];
      a[offset + 8] = e[6];
      a[offset + 9] = e[7];
      a[offset + 10] = e[8];
      updated = true;
    }
    return updated;
  }
  updateMatrix4(uniform) {
    let updated = false;
    const a = this.buffer;
    const e = uniform.getValue().elements;
    const offset = uniform.offset;
    if (arraysEqual(a, e, offset) === false) {
      a.set(e, offset);
      updated = true;
    }
    return updated;
  }
};
function arraysEqual(a, b, offset) {
  for (let i = 0, l = b.length; i < l; i++) {
    if (a[offset + i] !== b[i])
      return false;
  }
  return true;
}
var WebGPUUniformsGroup_default = WebGPUUniformsGroup;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUUniform.js
var WebGPUUniform = class {
  constructor(name, value = null) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  setValue(value) {
    this.value = value;
  }
  getValue() {
    return this.value;
  }
};
var FloatUniform = class extends WebGPUUniform {
  constructor(name, value = 0) {
    super(name, value);
    this.isFloatUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends WebGPUUniform {
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends WebGPUUniform {
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends WebGPUUniform {
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends WebGPUUniform {
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix3Uniform = class extends WebGPUUniform {
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends WebGPUUniform {
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WebGPUNodeUniform.js
var FloatNodeUniform = class extends FloatUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUSampler.js
var WebGPUSampler = class extends WebGPUBinding_default {
  constructor(name, texture2) {
    super(name);
    this.isSampler = true;
    this.texture = texture2;
    this.type = GPUBindingType.Sampler;
    this.visibility = GPUShaderStage.FRAGMENT;
    this.samplerGPU = null;
  }
  getTexture() {
    return this.texture;
  }
};
var WebGPUSampler_default = WebGPUSampler;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WebGPUNodeSampler.js
var WebGPUNodeSampler = class extends WebGPUSampler_default {
  constructor(name, textureNode) {
    super(name, textureNode.value);
    this.textureNode = textureNode;
  }
  getTexture() {
    return this.textureNode.value;
  }
};
var WebGPUNodeSampler_default = WebGPUNodeSampler;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUSampledTexture.js
var WebGPUSampledTexture = class extends WebGPUBinding_default {
  constructor(name, texture2) {
    super(name);
    this.isSampledTexture = true;
    this.texture = texture2;
    this.dimension = GPUTextureViewDimension.TwoD;
    this.type = GPUBindingType.SampledTexture;
    this.visibility = GPUShaderStage.FRAGMENT;
    this.aspect = texture2.isDepthTexture ? GPUTextureAspect.DepthOnly : GPUTextureAspect.All;
    this.textureGPU = null;
  }
  getTexture() {
    return this.texture;
  }
};
var WebGPUSampledCubeTexture = class extends WebGPUSampledTexture {
  constructor(name, texture2) {
    super(name, texture2);
    this.isSampledCubeTexture = true;
    this.dimension = GPUTextureViewDimension.Cube;
  }
};

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WebGPUNodeSampledTexture.js
var WebGPUNodeSampledTexture = class extends WebGPUSampledTexture {
  constructor(name, textureNode) {
    super(name, textureNode.value);
    this.textureNode = textureNode;
  }
  getTexture() {
    return this.textureNode.value;
  }
};
var WebGPUNodeSampledCubeTexture = class extends WebGPUSampledCubeTexture {
  constructor(name, textureNode) {
    super(name, textureNode.value);
    this.textureNode = textureNode;
  }
  getTexture() {
    return this.textureNode.value;
  }
};

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUStorageBuffer.js
var WebGPUStorageBuffer = class extends WebGPUBuffer_default {
  constructor(name, attribute) {
    super(name, GPUBindingType.StorageBuffer, attribute.array);
    this.isStorageBuffer = true;
    this.usage |= GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE;
    this.attribute = attribute;
  }
};
var WebGPUStorageBuffer_default = WebGPUStorageBuffer;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderTarget.js
var WebGPURenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options = {}) {
    super(width, height, options);
  }
};
var WebGPURenderTarget_default = WebGPURenderTarget;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WebGPUNodeBuilder.js
var gpuShaderStageLib = {
  "vertex": GPUShaderStage.VERTEX,
  "fragment": GPUShaderStage.FRAGMENT,
  "compute": GPUShaderStage.COMPUTE
};
var supports = {
  instance: true
};
var wgslTypeLib = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat3: "mat3x3<f32>",
  imat3: "mat3x3<i32>",
  umat3: "mat3x3<u32>",
  bmat3: "mat3x3<bool>",
  mat4: "mat4x4<f32>",
  imat4: "mat4x4<i32>",
  umat4: "mat4x4<u32>",
  bmat4: "mat4x4<bool>"
};
var wgslMethods = {
  dFdx: "dpdx",
  dFdy: "dpdy",
  mod: "threejs_mod",
  lessThanEqual: "threejs_lessThanEqual",
  inversesqrt: "inverseSqrt"
};
var wgslPolyfill = {
  lessThanEqual: new CodeNode_default(`
fn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );

}
`),
  mod: new CodeNode_default(`
fn threejs_mod( x : f32, y : f32 ) -> f32 {

	return x - y * floor( x / y );

}
`),
  repeatWrapping: new CodeNode_default(`
fn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`)
};
var WebGPUNodeBuilder = class extends NodeBuilder_default {
  constructor(object, renderer) {
    super(object, renderer, new WGSLNodeParser_default());
    this.bindings = { vertex: [], fragment: [], compute: [] };
    this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
    this.uniformsGroup = {};
    this.builtins = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map(),
      attribute: /* @__PURE__ */ new Map()
    };
  }
  build() {
    const { object, material } = this;
    if (material !== null) {
      NodeMaterial_default.fromMaterial(material).build(this);
    } else {
      this.addFlow("compute", object);
    }
    return super.build();
  }
  getSampler(textureProperty, uvSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
    } else {
      this._include("repeatWrapping");
      const dimension = `textureDimensions( ${textureProperty}, 0 )`;
      return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), 0 )`;
    }
  }
  getVideoSampler(textureProperty, uvSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;
    } else {
      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);
    }
  }
  getSamplerLevel(textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
    } else {
      this._include("repeatWrapping");
      const dimension = `textureDimensions( ${textureProperty}, 0 )`;
      return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${biasSnippet} ) )`;
    }
  }
  getTexture(texture2, textureProperty, uvSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (texture2.isVideoTexture === true) {
      snippet = this.getVideoSampler(textureProperty, uvSnippet, shaderStage);
    } else {
      snippet = this.getSampler(textureProperty, uvSnippet, shaderStage);
    }
    return snippet;
  }
  getTextureLevel(texture2, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (texture2.isVideoTexture === true) {
      snippet = this.getVideoSampler(textureProperty, uvSnippet, shaderStage);
    } else {
      snippet = this.getSamplerLevel(textureProperty, uvSnippet, biasSnippet, shaderStage);
    }
    return snippet;
  }
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeVarying === true && node.needsInterpolation === true) {
      if (shaderStage === "vertex") {
        return `NodeVaryings.${node.name}`;
      }
    } else if (node.isNodeUniform === true) {
      const name = node.name;
      const type = node.type;
      if (type === "texture" || type === "cubeTexture") {
        return name;
      } else if (type === "buffer" || type === "storageBuffer") {
        return `NodeBuffer_${node.node.id}.${name}`;
      } else {
        return `NodeUniforms.${name}`;
      }
    }
    return super.getPropertyName(node);
  }
  getBindings() {
    const bindings = this.bindings;
    return this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute;
  }
  getUniformFromNode(node, shaderStage, type) {
    const uniformNode = super.getUniformFromNode(node, shaderStage, type);
    const nodeData = this.getDataFromNode(node, shaderStage);
    if (nodeData.uniformGPU === void 0) {
      let uniformGPU;
      const bindings = this.bindings[shaderStage];
      if (type === "texture" || type === "cubeTexture") {
        const sampler = new WebGPUNodeSampler_default(`${uniformNode.name}_sampler`, uniformNode.node);
        let texture2 = null;
        if (type === "texture") {
          texture2 = new WebGPUNodeSampledTexture(uniformNode.name, uniformNode.node);
        } else if (type === "cubeTexture") {
          texture2 = new WebGPUNodeSampledCubeTexture(uniformNode.name, uniformNode.node);
        }
        const lastBinding = bindings[bindings.length - 1];
        const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;
        if (shaderStage === "fragment") {
          bindings.splice(index, 0, sampler, texture2);
          uniformGPU = [sampler, texture2];
        } else {
          bindings.splice(index, 0, texture2);
          uniformGPU = [texture2];
        }
      } else if (type === "buffer" || type === "storageBuffer") {
        const bufferClass = type === "storageBuffer" ? WebGPUStorageBuffer_default : WebGPUUniformBuffer_default;
        const buffer = new bufferClass("NodeBuffer_" + node.id, node.value);
        buffer.setVisibility(gpuShaderStageLib[shaderStage]);
        const lastBinding = bindings[bindings.length - 1];
        const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;
        bindings.splice(index, 0, buffer);
        uniformGPU = buffer;
      } else {
        let uniformsGroup = this.uniformsGroup[shaderStage];
        if (uniformsGroup === void 0) {
          uniformsGroup = new WebGPUUniformsGroup_default("nodeUniforms");
          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
          this.uniformsGroup[shaderStage] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        if (node.isArrayUniformNode === true) {
          uniformGPU = [];
          for (const uniformNode2 of node.nodes) {
            const uniformNodeGPU = this._getNodeUniform(uniformNode2, type);
            uniformNodeGPU.boundary = getVectorLength(uniformNodeGPU.itemSize);
            uniformNodeGPU.itemSize = getStrideLength(uniformNodeGPU.itemSize);
            uniformsGroup.addUniform(uniformNodeGPU);
            uniformGPU.push(uniformNodeGPU);
          }
        } else {
          uniformGPU = this._getNodeUniform(uniformNode, type);
          uniformsGroup.addUniform(uniformGPU);
        }
      }
      nodeData.uniformGPU = uniformGPU;
      if (shaderStage === "vertex") {
        this.bindingsOffset["fragment"] = bindings.length;
      }
    }
    return uniformNode;
  }
  isReference(type) {
    return super.isReference(type) || type === "texture_2d" || type === "texture_cube";
  }
  getBuiltin(name, property, type, shaderStage = this.shaderStage) {
    const map = this.builtins[shaderStage];
    if (map.has(name) === false) {
      map.set(name, {
        name,
        property,
        type
      });
    }
    return property;
  }
  getInstanceIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute");
    }
    return "instanceIndex";
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>", "fragment");
  }
  isFlipY() {
    return false;
  }
  getAttributes(shaderStage) {
    const snippets = [];
    if (shaderStage === "compute") {
      this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute");
    }
    if (shaderStage === "vertex" || shaderStage === "compute") {
      for (const { name, property, type } of this.builtins.attribute.values()) {
        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);
      }
      const attributes = this.attributes;
      const length = attributes.length;
      for (let index = 0; index < length; index++) {
        const attribute = attributes[index];
        const name = attribute.name;
        const type = this.getType(attribute.type);
        snippets.push(`@location( ${index} ) ${name} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    for (const variable of vars) {
      const name = variable.name;
      const type = this.getType(variable.type);
      snippets.push(`	var ${name} : ${type};`);
    }
    return `
${snippets.join("\n")}
`;
  }
  getVaryings(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
    }
    if (shaderStage === "vertex" || shaderStage === "fragment") {
      const varyings = this.varyings;
      const vars = this.vars[shaderStage];
      for (let index = 0; index < varyings.length; index++) {
        const varying = varyings[index];
        if (varying.needsInterpolation) {
          snippets.push(`@location( ${index} ) ${varying.name} : ${this.getType(varying.type)}`);
        } else if (vars.includes(varying) === false) {
          vars.push(varying);
        }
      }
    }
    for (const { name, property, type } of this.builtins[shaderStage].values()) {
      snippets.push(`@builtin( ${name} ) ${property} : ${type}`);
    }
    const code = snippets.join(",\n	");
    return shaderStage === "vertex" ? this._getWGSLStruct("NodeVaryingsStruct", "	" + code) : code;
  }
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const bufferSnippets = [];
    const groupSnippets = [];
    let index = this.bindingsOffset[shaderStage];
    for (const uniform of uniforms) {
      if (uniform.type === "texture" || uniform.type === "cubeTexture") {
        if (shaderStage === "fragment") {
          bindingSnippets.push(`@group( 0 ) @binding( ${index++} ) var ${uniform.name}_sampler : sampler;`);
        }
        const texture2 = uniform.node.value;
        let textureType;
        if (texture2.isCubeTexture === true) {
          textureType = "texture_cube<f32>";
        } else if (texture2.isDepthTexture === true) {
          textureType = "texture_depth_2d";
        } else if (texture2.isVideoTexture === true) {
          textureType = "texture_external";
        } else {
          textureType = "texture_2d<f32>";
        }
        bindingSnippets.push(`@group( 0 ) @binding( ${index++} ) var ${uniform.name} : ${textureType};`);
      } else if (uniform.type === "buffer" || uniform.type === "storageBuffer") {
        const bufferNode = uniform.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? ", " + bufferCount : "";
        const bufferSnippet = `	${uniform.name} : array< ${bufferType}${bufferCountSnippet} >
`;
        const bufferAccessMode = bufferNode.isStorageBufferNode ? "storage,read_write" : "uniform";
        bufferSnippets.push(this._getWGSLStructBinding("NodeBuffer_" + bufferNode.id, bufferSnippet, bufferAccessMode, index++));
      } else {
        const vectorType = this.getType(this.getVectorType(uniform.type));
        if (Array.isArray(uniform.value) === true) {
          const length = uniform.value.length;
          groupSnippets.push(`uniform ${vectorType}[ ${length} ] ${uniform.name}`);
        } else {
          groupSnippets.push(`	${uniform.name} : ${vectorType}`);
        }
      }
    }
    let code = bindingSnippets.join("\n");
    code += bufferSnippets.join("\n");
    if (groupSnippets.length > 0) {
      code += this._getWGSLStructBinding("NodeUniforms", groupSnippets.join(",\n"), "uniform", index++);
    }
    return code;
  }
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    for (const shaderStage in shadersData) {
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0)
            flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n	";
          if (shaderStage === "vertex") {
            flow += "NodeVaryings.Vertex = ";
          } else if (shaderStage === "fragment") {
            flow += "return ";
          }
          flow += `${flowSlotData.result};`;
        }
      }
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(", "));
    }
  }
  getRenderTarget(width, height, options) {
    return new WebGPURenderTarget_default(width, height, options);
  }
  getMethod(method) {
    if (wgslPolyfill[method] !== void 0) {
      this._include(method);
    }
    return wgslMethods[method] || method;
  }
  getType(type) {
    return wgslTypeLib[type] || type;
  }
  isAvailable(name) {
    return supports[name] === true;
  }
  _include(name) {
    wgslPolyfill[name].build(this);
  }
  _getNodeUniform(uniformNode, type) {
    if (type === "float")
      return new FloatNodeUniform(uniformNode);
    if (type === "vec2")
      return new Vector2NodeUniform(uniformNode);
    if (type === "vec3")
      return new Vector3NodeUniform(uniformNode);
    if (type === "vec4")
      return new Vector4NodeUniform(uniformNode);
    if (type === "color")
      return new ColorNodeUniform(uniformNode);
    if (type === "mat3")
      return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4")
      return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  _getWGSLVertexCode(shaderData) {
    return `${this.getSignature()}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> NodeVaryingsStruct {

	// system
	var NodeVaryings: NodeVaryingsStruct;

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return NodeVaryings;

}
`;
  }
  _getWGSLFragmentCode(shaderData) {
    return `${this.getSignature()}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> @location( 0 ) vec4<f32> {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  _getWGSLComputeCode(shaderData, workgroupSize) {
    return `${this.getSignature()}
// system
var<private> instanceIndex : u32;

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x;

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  _getWGSLStruct(name, vars) {
    return `
struct ${name} {
${vars}
};`;
  }
  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {
    const structName = name + "Struct";
    const structSnippet = this._getWGSLStruct(structName, vars);
    return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
  }
};
var WebGPUNodeBuilder_default = WebGPUNodeBuilder;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WebGPUNodes.js
var WebGPUNodes = class {
  constructor(renderer, properties) {
    this.renderer = renderer;
    this.properties = properties;
    this.nodeFrame = new NodeFrame_default();
  }
  get(renderObject) {
    const renderObjectProperties = this.properties.get(renderObject);
    let nodeBuilder = renderObjectProperties.nodeBuilder;
    if (nodeBuilder === void 0) {
      nodeBuilder = new WebGPUNodeBuilder_default(renderObject.object, this.renderer);
      nodeBuilder.material = renderObject.material;
      nodeBuilder.lightsNode = renderObject.lightsNode;
      nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);
      nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
      nodeBuilder.toneMappingNode = this.getToneMappingNode();
      nodeBuilder.build();
      renderObjectProperties.nodeBuilder = nodeBuilder;
    }
    return nodeBuilder;
  }
  getForCompute(computeNode) {
    const computeProperties = this.properties.get(computeNode);
    let nodeBuilder = computeProperties.nodeBuilder;
    if (nodeBuilder === void 0) {
      nodeBuilder = new WebGPUNodeBuilder_default(computeNode, this.renderer);
      nodeBuilder.build();
      computeProperties.nodeBuilder = nodeBuilder;
    }
    return nodeBuilder;
  }
  remove(renderObject) {
    const objectProperties = this.properties.get(renderObject);
    delete objectProperties.nodeBuilder;
  }
  getEnvironmentNode(scene) {
    return scene.environmentNode || this.properties.get(scene).environmentNode || null;
  }
  getFogNode(scene) {
    return scene.fogNode || this.properties.get(scene).fogNode || null;
  }
  getToneMappingNode() {
    return this.renderer.toneMappingNode || this.properties.get(this.renderer).toneMappingNode || null;
  }
  getCacheKey(scene, lightsNode) {
    const environmentNode = this.getEnvironmentNode(scene);
    const fogNode = this.getFogNode(scene);
    const toneMappingNode = this.getToneMappingNode();
    const cacheKey = [];
    if (lightsNode)
      cacheKey.push("lightsNode:" + lightsNode.getCacheKey());
    if (environmentNode)
      cacheKey.push("environmentNode:" + environmentNode.getCacheKey());
    if (fogNode)
      cacheKey.push("fogNode:" + fogNode.getCacheKey());
    if (toneMappingNode)
      cacheKey.push("toneMappingNode:" + toneMappingNode.getCacheKey());
    return "{" + cacheKey.join(",") + "}";
  }
  updateToneMapping() {
    const renderer = this.renderer;
    const rendererProperties = this.properties.get(renderer);
    const rendererToneMapping = renderer.toneMapping;
    if (rendererToneMapping !== NoToneMapping) {
      if (rendererProperties.toneMapping !== rendererToneMapping) {
        rendererProperties.toneMappingNode = toneMapping(rendererToneMapping, reference("toneMappingExposure", "float", renderer));
        rendererProperties.toneMapping = rendererToneMapping;
      }
    } else {
      delete rendererProperties.toneMappingNode;
      delete rendererProperties.toneMapping;
    }
  }
  updateBackground(scene) {
    const sceneProperties = this.properties.get(scene);
    const background = scene.background;
    if (background) {
      if (sceneProperties.background !== background) {
        let backgroundNode = null;
        if (background.isCubeTexture === true) {
          backgroundNode = cubeTexture(background, transformDirection(positionWorld, modelWorldMatrix));
        } else if (background.isTexture === true) {
          let nodeUV = null;
          if (background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping) {
            nodeUV = equirectUV();
          } else {
            nodeUV = viewportBottomLeft;
          }
          backgroundNode = texture(background, nodeUV);
        } else if (background.isColor !== true) {
          console.error("WebGPUNodes: Unsupported background configuration.", background);
        }
        sceneProperties.backgroundNode = backgroundNode;
        sceneProperties.background = background;
      }
    } else if (sceneProperties.backgroundNode) {
      delete sceneProperties.backgroundNode;
      delete sceneProperties.background;
    }
  }
  updateFog(scene) {
    const sceneProperties = this.properties.get(scene);
    const fog = scene.fog;
    if (fog) {
      if (sceneProperties.fog !== fog) {
        let fogNode = null;
        if (fog.isFogExp2) {
          fogNode = densityFog(reference("color", "color", fog), reference("density", "float", fog));
        } else if (fog.isFog) {
          fogNode = rangeFog(reference("color", "color", fog), reference("near", "float", fog), reference("far", "float", fog));
        } else {
          console.error("WebGPUNodes: Unsupported fog configuration.", fog);
        }
        sceneProperties.fogNode = fogNode;
        sceneProperties.fog = fog;
      }
    } else {
      delete sceneProperties.fogNode;
      delete sceneProperties.fog;
    }
  }
  updateEnvironment(scene) {
    const sceneProperties = this.properties.get(scene);
    const environment = scene.environment;
    if (environment) {
      if (sceneProperties.environment !== environment) {
        let environmentNode = null;
        if (environment.isCubeTexture === true) {
          environmentNode = cubeTexture(environment);
        } else if (environment.isTexture === true) {
          environmentNode = texture(environment);
        } else {
          console.error("WebGPUNodes: Unsupported environment configuration.", environment);
        }
        sceneProperties.environmentNode = environmentNode;
        sceneProperties.environment = environment;
      }
    } else if (sceneProperties.environmentNode) {
      delete sceneProperties.environmentNode;
      delete sceneProperties.environment;
    }
  }
  getNodeFrame(renderObject) {
    const nodeFrame = this.nodeFrame;
    nodeFrame.scene = renderObject.scene;
    nodeFrame.object = renderObject.object;
    nodeFrame.camera = renderObject.camera;
    nodeFrame.renderer = renderObject.renderer;
    nodeFrame.material = renderObject.material;
    return nodeFrame;
  }
  updateBefore(renderObject) {
    const nodeFrame = this.getNodeFrame(renderObject);
    const nodeBuilder = this.get(renderObject);
    for (const node of nodeBuilder.updateBeforeNodes) {
      nodeFrame.updateBeforeNode(node);
    }
  }
  update(renderObject) {
    const nodeFrame = this.getNodeFrame(renderObject);
    const nodeBuilder = this.get(renderObject);
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  dispose() {
    this.nodeFrame = new NodeFrame_default();
  }
};
var WebGPUNodes_default = WebGPUNodes;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUUtils.js
var WebGPUUtils = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  getCurrentColorSpace() {
    const renderer = this.renderer;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget !== null) {
      return renderTarget.texture.colorSpace;
    }
    return renderer.outputColorSpace;
  }
  getCurrentColorFormat() {
    let format;
    const renderer = this.renderer;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget !== null) {
      const renderTargetProperties = renderer._properties.get(renderTarget);
      format = renderTargetProperties.colorTextureFormat;
    } else {
      format = GPUTextureFormat.BGRA8Unorm;
    }
    return format;
  }
  getCurrentDepthStencilFormat() {
    let format;
    const renderer = this.renderer;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget !== null) {
      const renderTargetProperties = renderer._properties.get(renderTarget);
      format = renderTargetProperties.depthTextureFormat;
    } else {
      format = GPUTextureFormat.Depth24PlusStencil8;
    }
    return format;
  }
  getPrimitiveTopology(object, material) {
    if (object.isPoints)
      return GPUPrimitiveTopology.PointList;
    else if (object.isLineSegments || object.isMesh && material.wireframe === true)
      return GPUPrimitiveTopology.LineList;
    else if (object.isLine)
      return GPUPrimitiveTopology.LineStrip;
    else if (object.isMesh)
      return GPUPrimitiveTopology.TriangleList;
  }
  getSampleCount() {
    return this.renderer._parameters.sampleCount;
  }
};
var WebGPUUtils_default = WebGPUUtils;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderer.js
console.info("THREE.WebGPURenderer: Modified Matrix4.makePerspective() and Matrix4.makeOrtographic() to work with WebGPU, see https://github.com/mrdoob/three.js/issues/20276.");
Matrix4.prototype.makePerspective = function(left, right, top, bottom, near, far) {
  const te = this.elements;
  const x = 2 * near / (right - left);
  const y = 2 * near / (top - bottom);
  const a = (right + left) / (right - left);
  const b = (top + bottom) / (top - bottom);
  const c = -far / (far - near);
  const d = -far * near / (far - near);
  te[0] = x;
  te[4] = 0;
  te[8] = a;
  te[12] = 0;
  te[1] = 0;
  te[5] = y;
  te[9] = b;
  te[13] = 0;
  te[2] = 0;
  te[6] = 0;
  te[10] = c;
  te[14] = d;
  te[3] = 0;
  te[7] = 0;
  te[11] = -1;
  te[15] = 0;
  return this;
};
Matrix4.prototype.makeOrthographic = function(left, right, top, bottom, near, far) {
  const te = this.elements;
  const w = 1 / (right - left);
  const h = 1 / (top - bottom);
  const p = 1 / (far - near);
  const x = (right + left) * w;
  const y = (top + bottom) * h;
  const z = near * p;
  te[0] = 2 * w;
  te[4] = 0;
  te[8] = 0;
  te[12] = -x;
  te[1] = 0;
  te[5] = 2 * h;
  te[9] = 0;
  te[13] = -y;
  te[2] = 0;
  te[6] = 0;
  te[10] = -1 * p;
  te[14] = -z;
  te[3] = 0;
  te[7] = 0;
  te[11] = 0;
  te[15] = 1;
  return this;
};
Frustum.prototype.setFromProjectionMatrix = function(m) {
  const planes = this.planes;
  const me = m.elements;
  const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
  const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
  const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
  const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
  planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
  planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
  planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
  planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
  planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
  planes[5].setComponents(me2, me6, me10, me14).normalize();
  return this;
};
var _frustum = new Frustum();
var _projScreenMatrix = new Matrix4();
var _vector3 = new Vector3();
var WebGPURenderer = class {
  constructor(parameters = {}) {
    this.isWebGPURenderer = true;
    this.domElement = parameters.canvas !== void 0 ? parameters.canvas : this._createCanvasElement();
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.sortObjects = true;
    this._parameters = Object.assign({}, parameters);
    this._pixelRatio = 1;
    this._width = this.domElement.width;
    this._height = this.domElement.height;
    this._viewport = null;
    this._scissor = null;
    this._adapter = null;
    this._device = null;
    this._context = null;
    this._colorBuffer = null;
    this._depthBuffer = null;
    this._info = null;
    this._properties = null;
    this._attributes = null;
    this._geometries = null;
    this._nodes = null;
    this._bindings = null;
    this._objects = null;
    this._renderPipelines = null;
    this._computePipelines = null;
    this._renderLists = null;
    this._renderStates = null;
    this._textures = null;
    this._background = null;
    this._animation = new WebGPUAnimation_default();
    this._currentRenderState = null;
    this._opaqueSort = null;
    this._transparentSort = null;
    this._clearAlpha = 1;
    this._clearColor = new Color(0);
    this._clearDepth = 1;
    this._clearStencil = 0;
    this._renderTarget = null;
    this._initialized = false;
    this._parameters.antialias = parameters.antialias === true;
    if (this._parameters.antialias === true) {
      this._parameters.sampleCount = parameters.sampleCount === void 0 ? 4 : parameters.sampleCount;
    } else {
      this._parameters.sampleCount = 1;
    }
    this._parameters.requiredLimits = parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
    this.shadow = {
      shadowMap: {}
    };
  }
  async init() {
    if (this._initialized === true) {
      throw new Error("WebGPURenderer: Device has already been initialized.");
    }
    const parameters = this._parameters;
    const adapterOptions = {
      powerPreference: parameters.powerPreference
    };
    const adapter = await navigator.gpu.requestAdapter(adapterOptions);
    if (adapter === null) {
      throw new Error("WebGPURenderer: Unable to create WebGPU adapter.");
    }
    const features = Object.values(GPUFeatureName);
    const supportedFeatures = [];
    for (const name of features) {
      if (adapter.features.has(name)) {
        supportedFeatures.push(name);
      }
    }
    const deviceDescriptor = {
      requiredFeatures: supportedFeatures,
      requiredLimits: parameters.requiredLimits
    };
    const device = await adapter.requestDevice(deviceDescriptor);
    const context2 = parameters.context !== void 0 ? parameters.context : this.domElement.getContext("webgpu");
    this._adapter = adapter;
    this._device = device;
    this._context = context2;
    this._configureContext();
    this._info = new WebGPUInfo_default();
    this._properties = new WebGPUProperties_default();
    this._attributes = new WebGPUAttributes_default(device);
    this._geometries = new WebGPUGeometries_default(this._attributes, this._properties, this._info);
    this._textures = new WebGPUTextures_default(device, this._properties, this._info);
    this._utils = new WebGPUUtils_default(this);
    this._nodes = new WebGPUNodes_default(this, this._properties);
    this._objects = new WebGPURenderObjects_default(this, this._nodes, this._geometries, this._info);
    this._computePipelines = new WebGPUComputePipelines_default(device, this._nodes);
    this._renderPipelines = new WebGPURenderPipelines_default(device, this._nodes, this._utils);
    this._bindings = this._renderPipelines.bindings = new WebGPUBindings_default(device, this._info, this._properties, this._textures, this._renderPipelines, this._computePipelines, this._attributes, this._nodes);
    this._renderLists = new WebGPURenderLists_default();
    this._renderStates = new WebGPURenderStates_default();
    this._background = new WebGPUBackground_default(this, this._properties);
    this._setupColorBuffer();
    this._setupDepthBuffer();
    this._animation.setNodes(this._nodes);
    this._animation.start();
    this._initialized = true;
  }
  async render(scene, camera) {
    if (this._initialized === false)
      await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderState = this._currentRenderState;
    const renderState = this._renderStates.get(scene, camera);
    const renderTarget = this._renderTarget;
    this._currentRenderState = renderState;
    nodeFrame.renderId++;
    if (this._animation.isAnimating === false)
      nodeFrame.update();
    if (scene.matrixWorldAutoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
      camera.updateMatrixWorld();
    if (this._info.autoReset === true)
      this._info.reset();
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix);
    const renderList = this._renderLists.get(scene, camera);
    renderList.init();
    this._projectObject(scene, camera, 0, renderList);
    renderList.finish();
    if (this.sortObjects === true) {
      renderList.sort(this._opaqueSort, this._transparentSort);
    }
    renderState.descriptorGPU = {
      colorAttachments: [{
        view: null
      }],
      depthStencilAttachment: {
        view: null
      }
    };
    const colorAttachment = renderState.descriptorGPU.colorAttachments[0];
    const depthStencilAttachment = renderState.descriptorGPU.depthStencilAttachment;
    if (renderTarget !== null) {
      this._textures.initRenderTarget(renderTarget);
      const renderTargetProperties = this._properties.get(renderTarget);
      colorAttachment.view = renderTargetProperties.colorTextureGPU.createView();
      depthStencilAttachment.view = renderTargetProperties.depthTextureGPU.createView();
      renderState.stencil = renderTarget.depthTexture ? renderTarget.depthTexture.format !== DepthFormat : true;
    } else {
      if (this._parameters.antialias === true) {
        colorAttachment.view = this._colorBuffer.createView();
        colorAttachment.resolveTarget = this._context.getCurrentTexture().createView();
      } else {
        colorAttachment.view = this._context.getCurrentTexture().createView();
        colorAttachment.resolveTarget = void 0;
      }
      depthStencilAttachment.view = this._depthBuffer.createView();
    }
    this._nodes.updateEnvironment(scene);
    this._nodes.updateFog(scene);
    this._nodes.updateBackground(scene);
    this._nodes.updateToneMapping();
    this._background.update(scene, renderList, renderState);
    const device = this._device;
    renderState.encoderGPU = device.createCommandEncoder({});
    renderState.currentPassGPU = renderState.encoderGPU.beginRenderPass(renderState.descriptorGPU);
    const vp = this._viewport;
    if (vp !== null) {
      const width = Math.floor(vp.width * this._pixelRatio);
      const height = Math.floor(vp.height * this._pixelRatio);
      renderState.currentPassGPU.setViewport(vp.x, vp.y, width, height, vp.minDepth, vp.maxDepth);
    }
    const sc = this._scissor;
    if (sc !== null) {
      const width = Math.floor(sc.width * this._pixelRatio);
      const height = Math.floor(sc.height * this._pixelRatio);
      renderState.currentPassGPU.setScissorRect(sc.x, sc.y, width, height);
    }
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const lightsNode = renderList.lightsNode;
    if (opaqueObjects.length > 0)
      this._renderObjects(opaqueObjects, camera, scene, lightsNode, renderState);
    if (transparentObjects.length > 0)
      this._renderObjects(transparentObjects, camera, scene, lightsNode, renderState);
    renderState.currentPassGPU.end();
    device.queue.submit([renderState.encoderGPU.finish()]);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderState = previousRenderState;
  }
  setAnimationLoop(callback) {
    if (this._initialized === false)
      this.init();
    const animation = this._animation;
    animation.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  }
  async getArrayBuffer(attribute) {
    return await this._attributes.getArrayBuffer(attribute);
  }
  getContext() {
    return this._context;
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(target) {
    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(target) {
    return target.set(this._width, this._height);
  }
  setPixelRatio(value = 1) {
    this._pixelRatio = value;
    this.setSize(this._width, this._height, false);
  }
  setDrawingBufferSize(width, height, pixelRatio) {
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this.domElement.width = Math.floor(width * pixelRatio);
    this.domElement.height = Math.floor(height * pixelRatio);
    this._configureContext();
    this._setupColorBuffer();
    this._setupDepthBuffer();
  }
  setSize(width, height, updateStyle = true) {
    this._width = width;
    this._height = height;
    this.domElement.width = Math.floor(width * this._pixelRatio);
    this.domElement.height = Math.floor(height * this._pixelRatio);
    if (updateStyle === true) {
      this.domElement.style.width = width + "px";
      this.domElement.style.height = height + "px";
    }
    this._configureContext();
    this._setupColorBuffer();
    this._setupDepthBuffer();
  }
  setOpaqueSort(method) {
    this._opaqueSort = method;
  }
  setTransparentSort(method) {
    this._transparentSort = method;
  }
  getScissor(target) {
    const scissor = this._scissor;
    target.x = scissor.x;
    target.y = scissor.y;
    target.width = scissor.width;
    target.height = scissor.height;
    return target;
  }
  setScissor(x, y, width, height) {
    if (x === null) {
      this._scissor = null;
    } else {
      this._scissor = {
        x,
        y,
        width,
        height
      };
    }
  }
  copyFramebufferToRenderTarget(renderTarget) {
    const renderState = this._currentRenderState;
    const { encoderGPU, descriptorGPU } = renderState;
    const texture2 = renderTarget.texture;
    texture2.internalFormat = GPUTextureFormat.BGRA8Unorm;
    this._textures.initRenderTarget(renderTarget);
    const sourceGPU = this._context.getCurrentTexture();
    const destinationGPU = this._textures.getTextureGPU(texture2);
    renderState.currentPassGPU.end();
    encoderGPU.copyTextureToTexture(
      {
        texture: sourceGPU
      },
      {
        texture: destinationGPU
      },
      [
        texture2.image.width,
        texture2.image.height
      ]
    );
    descriptorGPU.colorAttachments[0].loadOp = GPULoadOp.Load;
    if (renderState.depth)
      descriptorGPU.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
    if (renderState.stencil)
      descriptorGPU.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
    renderState.currentPassGPU = encoderGPU.beginRenderPass(descriptorGPU);
  }
  getViewport(target) {
    const viewport = this._viewport;
    target.x = viewport.x;
    target.y = viewport.y;
    target.width = viewport.width;
    target.height = viewport.height;
    target.minDepth = viewport.minDepth;
    target.maxDepth = viewport.maxDepth;
    return target;
  }
  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
    if (x === null) {
      this._viewport = null;
    } else {
      this._viewport = {
        x,
        y,
        width,
        height,
        minDepth,
        maxDepth
      };
    }
  }
  getClearColor(target) {
    return target.copy(this._clearColor);
  }
  setClearColor(color, alpha = 1) {
    this._clearColor.set(color);
    this._clearAlpha = alpha;
  }
  getClearAlpha() {
    return this._clearAlpha;
  }
  setClearAlpha(alpha) {
    this._clearAlpha = alpha;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(depth) {
    this._clearDepth = depth;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(stencil) {
    this._clearStencil = stencil;
  }
  clear() {
    if (this._background)
      this._background.clear();
  }
  dispose() {
    this._objects.dispose();
    this._properties.dispose();
    this._renderPipelines.dispose();
    this._computePipelines.dispose();
    this._nodes.dispose();
    this._bindings.dispose();
    this._info.dispose();
    this._renderLists.dispose();
    this._renderStates.dispose();
    this._textures.dispose();
    this.setRenderTarget(null);
    this.setAnimationLoop(null);
  }
  setRenderTarget(renderTarget) {
    this._renderTarget = renderTarget;
  }
  async compute(...computeNodes) {
    if (this._initialized === false)
      await this.init();
    const device = this._device;
    const computePipelines = this._computePipelines;
    const cmdEncoder = device.createCommandEncoder({});
    const passEncoder = cmdEncoder.beginComputePass();
    for (const computeNode of computeNodes) {
      if (computePipelines.has(computeNode) === false) {
        computeNode.onInit({ renderer: this });
      }
      const pipeline = computePipelines.get(computeNode);
      passEncoder.setPipeline(pipeline);
      const bindGroup = this._bindings.getForCompute(computeNode).group;
      this._bindings.update(computeNode);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.dispatchWorkgroups(computeNode.dispatchCount);
    }
    passEncoder.end();
    device.queue.submit([cmdEncoder.finish()]);
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  hasFeature(name) {
    if (this._initialized === false) {
      throw new Error("THREE.WebGPURenderer: Renderer must be initialized before testing features.");
    }
    const features = Object.values(GPUFeatureName);
    if (features.includes(name) === false) {
      throw new Error("THREE.WebGPURenderer: Unknown WebGPU GPU feature: " + name);
    }
    return this._adapter.features.has(name);
  }
  _projectObject(object, camera, groupOrder, renderList) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        renderList.pushLight(object);
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (this.sortObjects === true) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = object.geometry;
          const material = object.material;
          if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isLineLoop) {
        console.error("THREE.WebGPURenderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          const geometry = object.geometry;
          const material = object.material;
          if (this.sortObjects === true) {
            if (geometry.boundingSphere === null)
              geometry.computeBoundingSphere();
            _vector3.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                renderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this._projectObject(children[i], camera, groupOrder, renderList);
    }
  }
  _renderObjects(renderList, camera, scene, lightsNode) {
    for (let i = 0, il = renderList.length; i < il; i++) {
      const renderItem = renderList[i];
      const { object, geometry, material, group } = renderItem;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            const vp = camera2.viewport;
            const minDepth = vp.minDepth === void 0 ? 0 : vp.minDepth;
            const maxDepth = vp.maxDepth === void 0 ? 1 : vp.maxDepth;
            this._currentRenderState.currentPassGPU.setViewport(vp.x, vp.y, vp.width, vp.height, minDepth, maxDepth);
            this._renderObject(object, scene, camera2, geometry, material, group, lightsNode);
          }
        }
      } else {
        this._renderObject(object, scene, camera, geometry, material, group, lightsNode);
      }
    }
  }
  _renderObject(object, scene, camera, geometry, material, group, lightsNode) {
    material = scene.overrideMaterial !== null ? scene.overrideMaterial : material;
    object.onBeforeRender(this, scene, camera, geometry, material, group);
    const renderObject = this._getRenderObject(object, material, scene, camera, lightsNode);
    this._nodes.updateBefore(renderObject);
    const passEncoder = this._currentRenderState.currentPassGPU;
    const info = this._info;
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    this._nodes.update(renderObject);
    this._geometries.update(renderObject);
    this._bindings.update(renderObject);
    const renderPipeline = this._renderPipelines.get(renderObject);
    passEncoder.setPipeline(renderPipeline.pipeline);
    const bindGroup = this._bindings.get(renderObject).group;
    passEncoder.setBindGroup(0, bindGroup);
    const index = this._geometries.getIndex(renderObject);
    const hasIndex = index !== null;
    if (hasIndex === true) {
      this._setupIndexBuffer(index, passEncoder);
    }
    this._setupVertexBuffers(geometry.attributes, passEncoder, renderPipeline);
    const drawRange = geometry.drawRange;
    const firstVertex = drawRange.start;
    const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.isInstancedMesh ? object.count : 1;
    if (hasIndex === true) {
      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;
      passEncoder.drawIndexed(indexCount, instanceCount, firstVertex, 0, 0);
      info.update(object, indexCount, instanceCount);
    } else {
      const positionAttribute = geometry.attributes.position;
      const vertexCount = drawRange.count !== Infinity ? drawRange.count : positionAttribute.count;
      passEncoder.draw(vertexCount, instanceCount, firstVertex, 0);
      info.update(object, vertexCount, instanceCount);
    }
  }
  _getRenderObject(object, material, scene, camera, lightsNode) {
    const renderObject = this._objects.get(object, material, scene, camera, lightsNode);
    const renderObjectProperties = this._properties.get(renderObject);
    if (renderObjectProperties.initialized !== true) {
      renderObjectProperties.initialized = true;
      const dispose = () => {
        this._renderPipelines.remove(renderObject);
        this._nodes.remove(renderObject);
        this._properties.remove(renderObject);
        this._objects.remove(object, material, scene, camera, lightsNode);
        renderObject.material.removeEventListener("dispose", dispose);
      };
      renderObject.material.addEventListener("dispose", dispose);
    }
    const cacheKey = renderObject.getCacheKey();
    if (renderObjectProperties.cacheKey !== cacheKey) {
      renderObjectProperties.cacheKey = cacheKey;
      this._renderPipelines.remove(renderObject);
      this._nodes.remove(renderObject);
    }
    return renderObject;
  }
  _setupIndexBuffer(index, encoder) {
    const buffer = this._attributes.get(index).buffer;
    const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
    encoder.setIndexBuffer(buffer, indexFormat);
  }
  _setupVertexBuffers(geometryAttributes, encoder, renderPipeline) {
    const shaderAttributes = renderPipeline.shaderAttributes;
    for (const shaderAttribute of shaderAttributes) {
      const name = shaderAttribute.name;
      const slot = shaderAttribute.slot;
      const attribute = geometryAttributes[name];
      if (attribute !== void 0) {
        const buffer = this._attributes.get(attribute).buffer;
        encoder.setVertexBuffer(slot, buffer);
      }
    }
  }
  _setupColorBuffer() {
    const device = this._device;
    if (device) {
      if (this._colorBuffer)
        this._colorBuffer.destroy();
      this._colorBuffer = this._device.createTexture({
        label: "colorBuffer",
        size: {
          width: Math.floor(this._width * this._pixelRatio),
          height: Math.floor(this._height * this._pixelRatio),
          depthOrArrayLayers: 1
        },
        sampleCount: this._parameters.sampleCount,
        format: GPUTextureFormat.BGRA8Unorm,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
    }
  }
  _setupDepthBuffer() {
    const device = this._device;
    if (device) {
      if (this._depthBuffer)
        this._depthBuffer.destroy();
      this._depthBuffer = this._device.createTexture({
        label: "depthBuffer",
        size: {
          width: Math.floor(this._width * this._pixelRatio),
          height: Math.floor(this._height * this._pixelRatio),
          depthOrArrayLayers: 1
        },
        sampleCount: this._parameters.sampleCount,
        format: GPUTextureFormat.Depth24PlusStencil8,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
    }
  }
  _configureContext() {
    const device = this._device;
    if (device) {
      this._context.configure({
        device,
        format: GPUTextureFormat.BGRA8Unorm,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        alphaMode: "premultiplied"
      });
    }
  }
  _createCanvasElement() {
    const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    canvas.style.display = "block";
    return canvas;
  }
};
var WebGPURenderer_default = WebGPURenderer;
export {
  WebGPURenderer_default as default
};
//# sourceMappingURL=three_addons_renderers_webgpu_WebGPURenderer__js.js.map
